{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA","file":"index.js","sourcesContent":["!function(n,o){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=o():\"function\"==typeof define&&define.amd?define([],o):\"object\"==typeof exports?exports.paddlejs=o():(n.paddlejs=n.paddlejs||{},n.paddlejs.webglBackend=o())}(this,(function(){return(()=>{var n={646:(n,o,e)=>{e.r(o),e.d(o,{GLHelper:()=>T,glInstance:()=>Tn,ops:()=>xn,webgl_types:()=>t});var t={};e.r(t),e.d(t,{UniformType:()=>c});var r={};e.r(r),e.d(r,{hardSigmoid:()=>k,leakyRelu:()=>R,pow_func:()=>M,prelu:()=>C,relu6:()=>O,scale:()=>S,scaleWidthBias:()=>I,sigmoid:()=>L,sqrt:()=>B,tanh_func:()=>D,transferFromNHWCtoNCHW:()=>A});var i={};function s(){var n;if(\"undefined\"!=typeof window)n=window;else if(void 0!==e.g)n=e.g;else{if(\"undefined\"==typeof self)throw new Error(\"Could not find a global object\");n=self}return n}function a(n,o){var e=s();return e[n]||(e[n]=o),e[n]}e.r(i),e.d(i,{getPixelsFromTexturePos:()=>G,getSamplerCode:()=>H,getTensorPosFromArrayIndex:()=>j,getValueFromTensorPos:()=>U,getValueFromTensorPosPacking:()=>N,moveTexture2PosToReal:()=>X});var u={opRegistry:{ops:{}},backend:\"\",backendInstance:null};u=a(\"GLOBALS\",u);var l=s();l.ImageBitmap||(l.ImageBitmap=function(){});const f=a(\"env\",new(function(){function n(){this.ENV={}}return n.prototype.set=function(n,o){this.ENV[n]=o},n.prototype.get=function(n){return this.ENV[n]},n}()));var c;!function(n){n.uniform1f=\"1f\",n.uniform1fv=\"1fv\",n.uniform1i=\"1i\",n.uniform1iv=\"1iv\",n.uniform2f=\"2f\",n.uniform2fv=\"2fv\",n.uniform2i=\"2i\",n.uniform2iv=\"2iv\",n.uniform3f=\"3f\",n.uniform3fv=\"3fv\",n.uniform3i=\"3i\",n.uniform3iv=\"3iv\",n.uniform4f=\"4f\",n.uniform4fv=\"4fv\",n.uniform4i=\"4i\",n.uniform4iv=\"4iv\"}(c||(c={}));function _(n){for(var o=n.length,e=function(){for(var n=0,o=0,e=arguments.length;o<e;o++)n+=arguments[o].length;var t=Array(n),r=0;for(o=0;o<e;o++)for(var i=arguments[o],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}(n),t=[];o>1;)e.splice(0,1),t.push(e.reduce((function(n,o){return n*o}))),o--;return t}function g(n){return n.reduce((function(n,o){return n*o}),1)}function h(n,o){return 0===n.length?\"\":n.reduce((function(o,e,t){return o+\"float(\"+e+\")\"+(t===n.length-1?\");\":\",\")}),\"float \"+o+\"[\"+n.length+\"] = float[](\")}function d(n,o){if(1===n.length)return\"float \"+o+\" = float(\"+n[0]+\");\";for(var e=n.length,t=\"\\n        vec\"+e+\" \"+o+\" = vec\"+e+\"(\\n    \",r=0;r<e;r++)t+=\"float(\"+n[r]+\"),\";return t.slice(0,-1)+\");\"}var p,P;!function(n){n[n.VS_SHADER=0]=\"VS_SHADER\",n[n.FS_SHADER=1]=\"FS_SHADER\"}(p||(p={})),function(n){n[n.FLOAT_VEC2=35664]=\"FLOAT_VEC2\",n[n.FLOAT_VEC3=35665]=\"FLOAT_VEC3\",n[n.FLOAT_VEC4=35666]=\"FLOAT_VEC4\",n[n.INT_VEC2=35667]=\"INT_VEC2\",n[n.INT_VEC3=35668]=\"INT_VEC3\",n[n.INT_VEC4=35669]=\"INT_VEC4\",n[n.BOOL=35670]=\"BOOL\",n[n.BOOL_VEC2=35671]=\"BOOL_VEC2\",n[n.BOOL_VEC3=35672]=\"BOOL_VEC3\",n[n.BOOL_VEC4=35673]=\"BOOL_VEC4\",n[n.FLOAT_MAT2=35674]=\"FLOAT_MAT2\",n[n.FLOAT_MAT3=35675]=\"FLOAT_MAT3\",n[n.FLOAT_MAT4=35676]=\"FLOAT_MAT4\",n[n.SAMPLER_2D=35677]=\"SAMPLER_2D\",n[n.SAMPLER_CUBE=35678]=\"SAMPLER_CUBE\",n[n.FLOAT=5126]=\"FLOAT\",n[n.INT=5124]=\"INT\"}(P||(P={}));var m,v=function(n,o,e){this.size=n,this.type=o,this.location=e},x=function(n,o,e){this.size=n,this.type=o,this.location=e},T=function(){function n(){}return n.getWebglVersion=function(){return f.get(\"webglVersion\")},n.createCanvas=function(){return f.get(\"canvas\")||document&&document.createElement(\"canvas\")},n.setWebglVersion=function(n){f.set(\"webglVersion\",n)},n.setWebGLRenderingContext=function(n){return this.gl=n,n},n.getWebGLRenderingContext=function(){return this.gl?this.gl:this.createWebGLRenderingContext()},n.createWebGLRenderingContext=function(){if(this.gl)return this.gl;var n=this.createCanvas();if(!n)return null;n.addEventListener&&n.addEventListener(\"webglcontextlost\",(function(n){throw n.preventDefault(),Error(\"webgl context is lost~\")}),!1);var o=n.getContext(\"webgl2\",this.WEBGL_ATTRIBUTES);return o?f.set(\"webglVersion\",2):(f.set(\"webglVersion\",1),o=n.getContext(\"webgl\",this.WEBGL_ATTRIBUTES)||n.getContext(\"experimental-webgl\",this.WEBGL_ATTRIBUTES)),o},n.printStates=function(n){console.log(\"1. isBlendEnable = \"+n.isEnabled(n.BLEND)),console.log(\"2. isCullFaceEnable = \"+n.isEnabled(n.CULL_FACE)),console.log(\"3. isDepthTestEnable = \"+n.isEnabled(n.DEPTH_TEST)),console.log(\"4. isDitherEnable = \"+n.isEnabled(n.DITHER)),console.log(\"5. isPolygonOffsetFillEnable = \"+n.isEnabled(n.POLYGON_OFFSET_FILL)),console.log(\"6. isSampleAlphtToCoverageEnable = \"+n.isEnabled(n.SAMPLE_ALPHA_TO_COVERAGE)),console.log(\"7. isSampleCoverageEnable = \"+n.isEnabled(n.SAMPLE_COVERAGE)),console.log(\"8. isScissorTestEnable = \"+n.isEnabled(n.SCISSOR_TEST)),console.log(\"9. isStencilTestEnable = \"+n.isEnabled(n.STENCIL_TEST))},n.printWebGLInfo=function(n){console.log(\"renderer = \"+n.getParameter(n.RENDERER)),console.log(\"version = \"+n.getParameter(n.VERSION)),console.log(\"vendor = \"+n.getParameter(n.VENDOR)),console.log(\"glsl version = \"+n.getParameter(n.SHADING_LANGUAGE_VERSION))},n.printWebGLTextureInfo=function(n){console.log(\"MAX_COMBINED_TEXTURE_IMAGE_UNITS = \",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),console.log(\"MAX_TEXTURE_IMAGE_UNITS = \",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)),console.log(\"MAX_TEXTURE_SIZE = \",n.getParameter(n.MAX_TEXTURE_SIZE)),console.log(\"MAX_CUBE_MAP_TEXTURE_SIZE = \",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE))},n.triggerContextLostEvent=function(n){var o=n.getExtension(\"WEBGL_lose_context\");null!==o&&o.loseContext()},n.checkGLError=function(n){var o=n.getError();return 0!==o&&(console.log(\"WebGL Error NO: \",o),!0)},n.setDefaultState=function(n){n.clearColor(0,0,0,0),n.clearDepth(1),n.enable(n.DEPTH_TEST),n.enable(n.CULL_FACE),n.enable(n.SCISSOR_TEST)},n.setViewport=function(n,o){n.viewport(o[0],o[1],o[2],o[3])},n.initShader=function(n,o,e){var t=this.createShader(n,o);return this.compileShader(n,e,t),t},n.createShader=function(n,o){var e;if(null===(e=o===p.VS_SHADER?n.createShader(n.VERTEX_SHADER):n.createShader(n.FRAGMENT_SHADER)))throw new Error(\"WebGLShader创建失败！\");return e},n.compileShader=function(n,o,e){return n.shaderSource(e,o),n.compileShader(e),!1!==n.getShaderParameter(e,n.COMPILE_STATUS)||(console.error(n.getShaderInfoLog(e)),n.deleteShader(e),!1)},n.createProgram=function(n){var o=n.createProgram();if(null===o)throw new Error(\"WebGLProgram创建失败！\");return o},n.linkProgram=function(n,o,e,t,r,i){return void 0===r&&(r=null),void 0===i&&(i=null),n.attachShader(o,e),n.attachShader(o,t),null!==r&&r(n,o),n.linkProgram(o),!1===n.getProgramParameter(o,n.LINK_STATUS)?(console.error(n.getProgramInfoLog(o)),n.deleteShader(e),n.deleteShader(t),n.deleteProgram(o),!1):(n.validateProgram(o),!1===n.getProgramParameter(o,n.VALIDATE_STATUS)?(console.error(n.getProgramInfoLog(o)),n.deleteShader(e),n.deleteShader(t),n.deleteProgram(o),!1):(null!==i&&i(n,o),!0))},n.getProgramActiveAttribs=function(n,o,e){for(var t=n.getProgramParameter(o,n.ACTIVE_ATTRIBUTES),r=0;r<t;r++){var i=n.getActiveAttrib(o,r);i&&(e[i.name]=new x(i.size,i.type,n.getAttribLocation(o,i.name)))}},n.getProgramAtciveUniforms=function(n,o,e){for(var t=n.getProgramParameter(o,n.ACTIVE_UNIFORMS),r=0;r<t;r++){var i=n.getActiveUniform(o,r);if(i){var s=n.getUniformLocation(o,i.name);null!==s&&(e[i.name]=new v(i.size,i.type,s))}}},n.createBuffer=function(n){var o=n.createBuffer();if(null===o)throw new Error(\"WebGLBuffer创建失败！\");return o},n.getColorBufferData=function(n){var o=new Uint8Array(n.drawingBufferWidth*n.drawingBufferHeight*4);return n.readPixels(0,0,n.drawingBufferWidth,n.drawingBufferHeight,n.RGBA,n.UNSIGNED_BYTE,o),o},n.setUniformParam=function(n,o,e,t){switch(e){case c.uniform1f:n.uniform1f(o,t);break;case c.uniform1fv:n.uniform1fv(o,t);break;case c.uniform1i:n.uniform1i(o,t);break;case c.uniform1iv:n.uniform1iv(o,t);break;case c.uniform2f:n.uniform2f(o,t[0],t[1]);break;case c.uniform2fv:n.uniform2fv(o,t);break;case c.uniform2i:n.uniform2i(o,t[0],t[1]);break;case c.uniform2iv:n.uniform2iv(o,t);break;case c.uniform3f:n.uniform3f(o,t[0],t[1],t[2]);break;case c.uniform3fv:n.uniform3fv(o,t);break;case c.uniform3i:n.uniform3i(o,t[0],t[1],t[2]);break;case c.uniform3iv:n.uniform3iv(o,t);break;case c.uniform4f:n.uniform4f(o,t[0],t[1],t[2],t[3]);break;case c.uniform4fv:n.uniform4fv(o,t);break;case c.uniform4i:n.uniform4i(o,t[0],t[1],t[2],t[3]);break;case c.uniform4iv:n.uniform4iv(o,t);break;default:console.error(\"[\"+e+\"]: unknown uniform type\")}},n.genTextureInfoFromTensorShape=function(n,o){var e=n||4096,t=o.shape,r=void 0===t?[]:t,i=function(){for(var n=0,o=0,e=arguments.length;o<e;o++)n+=arguments[o].length;var t=Array(n),r=0;for(o=0;o<e;o++)for(var i=arguments[o],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}(r).sort((function(n,o){return n-o})),s=i[0],a=i[1],u=i[2],l=s*i[3],c=a*u;if(l>e||c>e){var _=[l,c].sort((function(n,o){return n-o})),g=_[0],h=_[1],d=function(n,o){var e=o;if(n%e==0)return e;for(;e<n&&n%e!=0;)e++;return e}(h,Math.ceil(h/e));if(l=g*d,c=Math.ceil(h/d),f.get(\"debug\")&&console.error(\"大小超限\",r,[c,l]),l>e||c>e)throw new Error(\"Requested texture size [\"+l+\"x\"+c+\"] greater than WebGL maximum on this browser / GPU [\"+e+\"x\"+e+\"].\")}o.shape_texture=[c,l]},n.WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0,powerPreference:\"high-performance\"},n.gl=null,n}();!function(n){n[n.GL_REPEAT=0]=\"GL_REPEAT\",n[n.GL_MIRRORED_REPEAT=1]=\"GL_MIRRORED_REPEAT\",n[n.GL_CLAMP_TO_EDGE=2]=\"GL_CLAMP_TO_EDGE\"}(m||(m={}));var F=function(){function n(){}return n.getTextureConfig=function(n){var o,e,t,r,i,s,a,u,l=n,c=!0,_=!0;return 2===f.get(\"webglVersion\")?(o=l.getExtension(\"EXT_color_buffer_float\"),t=l.HALF_FLOAT,r=l.R32F,i=l.RGBA32F,s=l.R16F,a=l.RGBA16F,e=l.RED,u=l.RGBA32F):(r=l.RGBA,s=l.RGBA,a=l.RGBA,i=l.RGBA,e=l.RGBA,u=l.RGBA,o=l.getExtension(\"OES_texture_float\"),t=l.getExtension(\"OES_texture_half_float\").HALF_FLOAT_OES,c=this.isDownloadFloatTextureEnabled(l,u),_=this.isFloatTextureReadPixelsEnabledMethod(l,1,c)),{textureFloat:o,textureHalfFloat:t,internalFormat:r,internalFormatPacked:i,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,textureFormat:e,downloadInternalFormat:u,frameBufferSupportFloat:c,isFloatTextureReadPixelsEnabled:_}},n.isFloatTextureReadPixelsEnabledMethod=function(n,o,e){var t=n;if(0===o)return!1;if(1===o){if(null==t.getExtension(\"OES_texture_float\"))return!1}else if(null==t.getExtension(\"EXT_color_buffer_float\")||null==t.getExtension(\"EXT_color_buffer_half_float\"))return!1;var r=t.createFramebuffer(),i=t.createTexture();t.bindTexture(t.TEXTURE_2D,i);var s=2===o?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,s,1,1,0,t.RGBA,e?t.FLOAT:t.getExtension(\"OES_texture_half_float\").HALF_FLOAT_OES,null),t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,i,0);var a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;t.readPixels(0,0,1,1,t.RGBA,t.FLOAT,new Float32Array(4));var u=t.getError()===t.NO_ERROR;return a&&u},n.isDownloadFloatTextureEnabled=function(n,o){var e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,o,1,1,0,n.RGBA,n.FLOAT,null);var t=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,t),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);var r=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(t),r},n.uploadDataToTexture=function(n,o,e,t){n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);var r=e.width_texture,i=e.height_texture,s=e.data,a=n.RGBA,u=n.RGBA,l=n.FLOAT,c=s;if(s instanceof Uint8Array||s instanceof Uint8ClampedArray||!(s instanceof Float32Array||s instanceof Array))l=n.UNSIGNED_BYTE;else if(2===f.get(\"webglVersion\")){var _=f.get(\"webgl_force_half_float_texture\");a=t?_?o.internalFormatPackedHalfFloat:o.internalFormatPacked:_?o.internalFormatHalfFloat:o.internalFormat,u=t?n.RGBA:o.textureFormat}else{for(var g=new Float32Array(r*i*4),h=0;h<s.length;h++)t?g[h]=s[h]:(g[4*h]=s[h],g[4*h+1]=0,g[4*h+2]=0,g[4*h+3]=0);c=g}n.texImage2D(n.TEXTURE_2D,0,a,r,i,0,u,l,c)},n.genOutputTexture=function(n,o,e,t){var r=e.interpType,i=e.width_texture,s=e.height_texture,a=n.createTexture();n.bindTexture(n.TEXTURE_2D,a),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,\"LINEAR\"===r?n.LINEAR:n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,\"LINEAR\"===r?n.LINEAR:n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);var u=f.get(\"webgl_force_half_float_texture\"),l=u?o.internalFormatPackedHalfFloat:o.internalFormatPacked,c=2===f.get(\"webglVersion\")?u?n.HALF_FLOAT:n.FLOAT:o.frameBufferSupportFloat?n.FLOAT:o.textureHalfFloat,_=t?o.isFloatTextureReadPixelsEnabled?c:n.UNSIGNED_BYTE:null;return n.texImage2D(n.TEXTURE_2D,0,l,i,s,0,n.RGBA,t?_:c,null),n.bindTexture(n.TEXTURE_2D,null),a},n}(),b=[\"\\n    precision highp float;\\n    precision highp int;\\n\\n    attribute vec4 position;\\n    varying vec2 vCoord;\\n\\n    void main() {\\n        vCoord.x = (position.x + 1.0) / 2.0;\\n        vCoord.y = (position.y + 1.0) / 2.0;\\n        gl_Position = position;\\n    }\\n    \",\"#version 300 es\\n    in vec4 position;\\n    out vec2 vCoord;\\n\\n    void main() {\\n        vCoord.x = (position.x + 1.0) / 2.0;\\n        vCoord.y = (position.y + 1.0) / 2.0;\\n        gl_Position = position;\\n    }\\n    \"],y=new Float32Array([-1,1,-1,-1,1,1,1,-1]),E=[\"length_shape\",\"length_unformatted_shape\",\"width_shape\",\"height_shape\",\"width_texture\",\"height_texture\",\"offset_x\",\"offset_y\",\"channel\",\"total_shape\",\"numbers_shape\"],w={float:[\"multi_value\",\"bias_value\"],bool:[\"fuse_relu\"]};function V(){return\"\\n    \"+(f.get(\"useModAdaptor\")?\"\\n            int calMod(int a, int b) {\\n                float modV = mod(float(a), float(b));\\n                if (modV == float(b)) {\\n                    modV = 0.0;\\n                }\\n                return int(modV);\\n            }\\n        \":\"\\n            int calMod(int a, int b) {\\n                return a - a / b * b;\\n            }\\n        \")+\"\\n    \"+(f.get(\"useDivisionAdaptor\")?\"\\n            int calDivision(int a, int b) {\\n                return int(float(a) / (float(b) - 0.0001));\\n            }\\n        \":\"\\n            int calDivision(int a, int b) {\\n                return a / b;\\n            }\\n        \")+\"\\n    \\n    float tanh_calc(float num) {\\n        float res = (exp(2.0 * num) - 1.0) / (exp(2.0 * num) + 1.0);\\n        return res;\\n    }\\n    \\n    \"}const A=\"\\nivec4 transferFromNHWCtoNCHW(\\n    int sumVal,\\n    const int channel,\\n    const int width_shape,\\n    const int height_shape,\\n    const int total_shape) {\\n\\n    int n_origin = int(total_shape/(channel * width_shape * height_shape));\\n    int new_a = calMod(sumVal, width_shape);\\n    sumVal = int((sumVal - new_a) / width_shape);\\n    int new_b = calMod(sumVal, height_shape);\\n    sumVal = int((sumVal - new_b) / height_shape);\\n    int new_g = calMod(sumVal, channel);\\n    sumVal = int((sumVal - new_g) / channel);\\n    int new_r = calMod(sumVal, n_origin);\\n    return ivec4(new_r,new_g,new_b,new_a);\\n}\\n\";var C=\"\\nfloat prelu(float x, float p, float b) {\\n    float result = x;\\n    if (x < 0.0) {\\n        result = x * p;\\n    }\\n\\n    return result;\\n}\",O=\"\\nfloat relu6(float x, float threshold, float b) {\\n    float result = min(max(0.0, x), threshold);\\n    return result;\\n}\",R=\"\\nfloat leakyRelu(float x, float p, float b) {\\n    float result = max(x, x * p);\\n    return result;\\n}\",S=\"\\nfloat scale(float x, float p, float b) {\\n    float result = p * x + b;\\n    return result;\\n}\",I=\"\\nfloat scaleWidthBias(float x, float p, float b) {\\n    float result = p * (x + b);\\n    return result;\\n}\",L=\"\\nfloat sigmoid(float x, float y, float z) {\\n    float result = 1.0 / (1.0 + exp(-x));\\n    return result;\\n}\",k=\"\\n    float hardSigmoid(float x, float slope, float offset) {\\n        float result = max(0.0, min(1.0, slope * x + offset));\\n        return result;\\n    }\\n\",B=\"\\n    float sqrt(float x, float slope, float offset) {\\n        return sqrt(x);\\n    }\\n\",M=\"\\n    float pow_func(float x, float factor, float offset) {\\n        return pow(x, factor);\\n    }\\n\",D=\"\\nfloat tanh_func(float x, float y, float z) {\\n    return tanh_calc(x);\\n}\";function U(n,o){var e=o.width_shape,t=o.height_shape,r=o.channel,i=o.width_texture;return\"\\n    // 根据tensor坐标获取这个tensor位置的值\\n    float getValueFromTensorPos_\"+n+\"(int n, int c, int h, int w) {\\n        int index = n * \"+e*t*r+\" + c * \"+e*t+\" + h * \"+e+\" + w;\\n        int pos_w = int(mod(float(index), float(\"+i+\")));\\n        int pos_h = index / int(\"+i+\");\\n        vec4 pixels = TEXTURE2D(texture_\"+n+\",\\n            vec2(\\n                (float(pos_w)  + 0.5) / float(\"+i+\"),\\n                (float(pos_h) + 0.5) / float(\"+o.height_texture+\")\\n            )\\n        );\\n        // 只用了r通道\\n        return pixels.r;\\n    }\"}function N(n,o){var e=o.channel,t=o.height_shape,r=o.width_texture,i=o.height_texture,s=o.width_shape;return\"\\n    // 根据tensor坐标获取这个tensor位置的值\\n    vec4 getValueFromTensorPosPacking_\"+n+\"(int n, int c, int h, int w) {\\n        int index = n * \"+s*t*e+\" + c * \"+s*t+\" + h * \"+s+\" + w;\\n        int pos_w = int(mod(float(index), float(\"+r+\")));\\n        int pos_h = index / int(\"+r+\");\\n        vec4 pixels = TEXTURE2D(texture_\"+n+\",\\n            vec2(\\n                (float(pos_w)  + 0.5) / float(\"+r+\"),\\n                (float(pos_h) + 0.5) / float(\"+i+\")\\n            )\\n        );\\n        // 只用了r通道\\n        return pixels;\\n    }\"}function j(n,o){var e=o.numbers_shape,t=o.length_shape;if(1===t)return\"\\n            int getTensorPosFromArrayIndex_\"+n+\"(int n) {\\n                return calMod(n, \"+e[0]+\");\\n            }\\n        \";for(var r=\"ivec\"+t+\"(\"+e.join(\", \")+\")\",i=\"pos[0] = n / \"+e[0]+\";\",s=1;s<t;s++)i+=\"\\n            n = calMod(n, \"+e[s-1]+\");\\n            pos[\"+s+\"] = calDivision(n, \"+e[s]+\");\\n        \";return\"\\n    ivec\"+t+\" shapeVec_\"+n+\" = \"+r+\";\\n    ivec\"+t+\" getTensorPosFromArrayIndex_\"+n+\"(int n) {\\n        ivec\"+t+\" pos;\\n        \"+i+\"\\n        return pos;\\n    }\\n    \"}function G(n){return\"\\n    #define getPixelsFromTexturePos_\"+n+\"(pos) TEXTURE2D(texture_\"+n+\", pos)\\n    \"}function X(n,o){return\"\\n    vec2 moveTexture2PosToReal_\"+n+\"(vec2 v) {\\n        vec2 v2;\\n        v2.x = v.x * float(\"+o.width_texture+\");\\n        v2.y = v.y * float(\"+o.height_texture+\");\\n        return v2;\\n    }\\n    \"}function H(n){return\"uniform sampler2D texture_\"+n+\";\"}function W(n,o,e,t,s){var a,u,l=\"\",c=o.name,_=o.mainFunc,g=o.textureFuncConf,h=void 0===g?{}:g,d=o.commonFuncConf;try{var p=function(n,o,e){for(var t={},r=Object.assign({},o),i=[],s=0,a=n;s<a.length;s++){for(var u=a[s],l=u.name,f={},c=0,_=E;c<_.length;c++)void 0!==u[m=_[c]]&&(f[m]=u[m]);t[l]=f,i.push(l)}for(var g=0,h=Object.keys(w);g<h.length;g++)for(var d=h[g],p=0,P=w[d];p<P.length;p++){var m;void 0!==o[m=P[p]]&&(r[m]=d+\"(\"+o[m]+\")\")}return o.active_function&&(r.active_function=o.active_function),r.runtime=e,{textureParams:t,opParams:r,active_function:o.active_function}}(e,t,s),P=p.textureParams,m=p.opParams,v=p.active_function,x=2===f.get(\"webglVersion\")?\" #version 300 es\\n            #ifdef GL_FRAGMENT_PRECISION_HIGH\\n            precision highp float;\\n            precision highp int;\\n        #else\\n            precision mediump float;\\n            precision mediump int;\\n        #endif      \\n        \":\" #ifdef GL_FRAGMENT_PRECISION_HIGH\\n            precision highp float;\\n            precision highp int;\\n        #else\\n            precision highp float;\\n            precision highp int;\\n        #endif\\n        \",T=function(n){var o=n.frameBufferSupportFloat,e=n.isFinalOp,t=n.isFloatTextureReadPixelsEnabled;return 2===f.get(\"webglVersion\")?\"\\n        // 顶点shader透传的材质坐标\\n        in vec2 vCoord;\\n        out vec4 outColor;\\n        void setOutput(float result) {\\n            result = fuse_op(result);\\n            outColor.r = result;\\n        }\\n        void setPackedOutput(vec4 result) {\\n            outColor = result;\\n        }\\n        int calCeil(int a, int b) {\\n            return int(ceil(float(a) / float(b)));\\n        }\\n        \"+V()+\"\\n    \":o?\"\\n            varying vec2 vCoord;\\n            varying vec4 outColor;\\n            void setOutput(float result) {\\n                result = fuse_op(result);\\n                gl_FragColor.r = result;\\n            }\\n            void setPackedOutput(vec4 result) {\\n                gl_FragColor = result;\\n            }\\n            int calCeil(int a, int b) {\\n                return int(ceil(float(a) / float(b)));\\n            }\\n            \"+V()+\"\\n    \":e&&!t?\"\\n        varying vec2 vCoord;\\n        varying vec4 outColor;\\n\\n        const float FLOAT_MAX = 1.70141184e38;\\n        const float FLOAT_MIN = 1.17549435e-38;\\n\\n        #define isnan(value) isnan_custom(value)\\n        bool isnan_custom(float val) {\\n            return (val > 0. || val < 1. || val == 0.) ? false : true;\\n        }\\n\\n        \"+V()+\"\\n\\n        int calCeil(int a, int b) {\\n            return int(ceil(float(a) / float(b)));\\n        }\\n\\n        lowp vec4 encode_float(highp float v) {\\n            if (isnan(v)) {\\n            return vec4(255, 255, 255, 255);\\n            }\\n\\n            highp float av = abs(v);\\n\\n            if(av < FLOAT_MIN) {\\n            return vec4(0.0, 0.0, 0.0, 0.0);\\n            } else if(v > FLOAT_MAX) {\\n            return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n            } else if(v < -FLOAT_MAX) {\\n            return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n            }\\n\\n            highp vec4 c = vec4(0,0,0,0);\\n\\n            highp float e = floor(log2(av));\\n            highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n            c[2] = floor(128.0 * m);\\n            m -= c[2] / 128.0;\\n            c[1] = floor(32768.0 * m);\\n            m -= c[1] / 32768.0;\\n            c[0] = floor(8388608.0 * m);\\n\\n            highp float ebias = e + 127.0;\\n            c[3] = floor(ebias / 2.0);\\n            ebias -= c[3] * 2.0;\\n            c[2] += floor(ebias) * 128.0;\\n\\n            c[3] += 128.0 * step(0.0, -v);\\n\\n            return c / 255.0;\\n        }\\n\\n        void setOutput(float result) {\\n                result = fuse_op(result);\\n                gl_FragColor = encode_float(result);\\n        }\\n        \":\"\\n            #define isnan(value) isnan_custom(value)\\n            bool isnan_custom(float val) {\\n                return (val > 0. || val < 1. || val == 0.) ? false : true;\\n            }\\n\\n            varying vec2 vCoord;\\n            varying vec4 outColor;\\n            void setOutput(float result) {\\n                result = fuse_op(result);\\n                if(isnan(result)) {\\n                    gl_FragColor.r = 0.0;\\n                }else {\\n                    gl_FragColor.r = result;\\n                }\\n            }\\n\\n            void setPackedOutput(vec4 result) {\\n                gl_FragColor = result;\\n            }\\n\\n            \"+V()+\"\\n\\n            int calCeil(int a, int b) {\\n                return int(ceil(float(a) / float(b)));\\n            }\\n        \"}(n),F=function(n){var o=\"\",e=\"\";if(n.fuse_opt)for(var t in n.fuse_opt){var i=t,s=0,a=0;switch(t){case\"scale\":var u=n.fuse_opt.scale.bias_after_scale,l=n.fuse_opt.scale.scale;s=void 0!==l?l:1,a=n.fuse_opt.scale.bias||0,!1===u&&void 0!==u&&(i=\"scaleWidthBias\");break;case\"relu\":i=\"prelu\";break;case\"relu6\":s=n.fuse_opt[t].threshold;break;case\"hard_sigmoid\":i=\"hardSigmoid\",s=n.fuse_opt[t].slope||.2,a=n.fuse_opt[t].offset||.5;break;case\"leakyRelu\":s=n.fuse_opt[t].alpha;break;case\"pow\":i=\"pow_func\",s=n.fuse_opt[t].factor||2;break;case\"tanh\":i=\"tanh_func\"}o+=r[i],e+=\"res = \"+i+\"(x, float(\"+s+\"), float(\"+a+\"));\"}return\"\\n        \"+o+\"\\n        \\n        float fuse_op(float x) {\\n            float res = x;\\n            \"+e+\"\\n            return res;\\n        }\\n    \"}(m),b=function(n,o,e,t){if(!n)return\"\";var r=Object.assign({},n);r[\"@all\"]&&function(n,o){var e=o.filter((function(n){return\"out\"!==n.name})),t=n[\"@all\"];e.forEach((function(o){var e=o.name;n[e]?n[e].concat(t):n[e]=t})),delete n[\"@all\"]}(r,t);for(var s=\"\",a=\"\",u=0,l=Object.keys(r);u<l.length;u++){var f=l[u];if(o[f]){a+=H(f);for(var c=0,_=r[f];c<_.length;c++){var g=_[c];if(i[g])try{s+=i[g](f,o[f],e)}catch(n){console.error(n)}}}}return\"\\n    \"+a+\"\\n    \"+s+\"\\n    \"}(h,P,m,e),y=function(n){return void 0===n?\"\":\"\\n        int layer_run_time = \"+n+\";\\n    \"}(s),A=function(n){var o,e,t,r,i;return\"\\n        \\n    vec2 _2d_shape_texture_out = vec2(float(\"+n.width_texture+\"), float(\"+n.height_texture+\"));\\n    \\n        \"+(e=(o=n).height_shape,t=o.width_shape,\"\\n    ivec4 getOutputTensorPos() {\\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\\n        int index = int(outCoord.x) + int(outCoord.y) * int(\"+o.width_texture+\");\\n\\n        int n1 = int(index / \"+(r=t*e*o.channel)+\");\\n        int c1 = int(calMod(index, \"+r+\") / \"+(i=t*e)+\");\\n        int h1 = int(calMod(index, \"+i+\") / \"+t+\");\\n        int w1 = calMod(index, \"+t+\");\\n        return ivec4(n1, c1, h1, w1);\\n    }\\n    \\n    \")}(P.out),C=function(n){if(!n)return\"\";for(var o=\"\",e=0,t=n;e<t.length;e++){var i=t[e];r[i]&&(o+=r[i])}return o}(d);a=l=\" \"+x+\"\\n            \"+F+\"\\n            \"+T+\"\\n            \"+C+\"\\n            \"+(v?r[v]:\"\")+\"\\n            \"+b+\"\\n            \"+y+\"\\n            \"+A+\"\\n            \"+_(P,m)+\"\\n        \",u=1===f.get(\"webglVersion\")?\"texture2D\":\"texture\",l=a.replace(/\\bTEXTURE2D\\b/g,u)}catch(n){console.error(\"[\"+c+\"]: \"+n)}return l}const z=function(){function n(n,o,e,t){var r=n;this.vShader=o;try{this.fShader=this.initShader(r,e,\"fragment\"),this.shape=t&&t.shape;var i=this.program=r.createProgram();r.attachShader(i,this.vShader),r.attachShader(i,this.fShader),r.linkProgram(i)}catch(n){throw new Error(n)}}return n.prototype.initShader=function(n,o,e){void 0===e&&(e=\"vertex\");var t,r=\"vertex\"===e?n.VERTEX_SHADER:n.FRAGMENT_SHADER;if(\"vertex\"===e&&this.vShader)t=this.vShader;else if(t=n.createShader(r),\"vertex\"===e&&(this.vShader=t),n.shaderSource(t,o),n.compileShader(t),!n.getShaderParameter(t,n.COMPILE_STATUS))throw new Error(\"compile: \"+n.getShaderInfoLog(t));return t},n.prototype.setProgram=function(n,o,e){n.useProgram(this.program),e||this.runVertexShader(n,o)},n.prototype.runVertexShader=function(n,o){var e=n.getAttribLocation(this.program,\"position\");n.enableVertexAttribArray(e),n.bindBuffer(n.ARRAY_BUFFER,o),n.vertexAttribPointer(e,2,n.FLOAT,!1,0,0)},n.Sampler=\"uSampler\",n}();var q,Y=(q=function(n,o){return(q=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,o){n.__proto__=o}||function(n,o){for(var e in o)Object.prototype.hasOwnProperty.call(o,e)&&(n[e]=o[e])})(n,o)},function(n,o){function e(){this.constructor=n}q(n,o),n.prototype=null===o?Object.create(o):(e.prototype=o.prototype,new e)}),Z=function(n,o,e,t){return new(e||(e=Promise))((function(r,i){function s(n){try{u(t.next(n))}catch(n){i(n)}}function a(n){try{u(t.throw(n))}catch(n){i(n)}}function u(n){var o;n.done?r(n.value):(o=n.value,o instanceof e?o:new e((function(n){n(o)}))).then(s,a)}u((t=t.apply(n,o||[])).next())}))},K=function(n,o){var e,t,r,i,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},\"function\"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(e)throw new TypeError(\"Generator is already executing.\");for(;s;)try{if(e=1,t&&(r=2&i[0]?t.return:i[0]?t.throw||((r=t.return)&&r.call(t),0):t.next)&&!(r=r.call(t,i[1])).done)return r;switch(t=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,t=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!((r=(r=s.trys).length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){s.label=i[1];break}if(6===i[0]&&s.label<r[1]){s.label=r[1],r=i;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(i);break}r[2]&&s.ops.pop(),s.trys.pop();continue}i=o.call(n,s)}catch(n){i=[6,n],t=0}finally{e=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}};const Q=function(n){function o(){var o=n.call(this)||this;return o.cacheTextures={},o.uniformLocations={},o.texturesMap={},o.queryList=[],o.currentTexture=null,o.width_shape_out=1,o.height_shape_out=1,o.width_texture_out=1,o.height_texture_out=1,o.channel=0,o.total_shape=0,o}return Y(o,n),o.prototype.init=function(){return Z(this,void 0,void 0,(function(){var n;return K(this,(function(o){return n=this.gl=T.createWebGLRenderingContext(),this.gl?(this.glVersion=T.getWebglVersion(),this.textureConf=F.getTextureConfig(n),this.MAX_TEXTURE_SIZE=f.get(\"MAX_TEXTURE_SIZE\")||n.getParameter(n.MAX_TEXTURE_SIZE),n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),this.vertexBuffer=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,this.vertexBuffer),n.bufferData(n.ARRAY_BUFFER,y,n.STATIC_DRAW),this.vShader=T.initShader(n,p.VS_SHADER,b[this.glVersion-1]),this.frameBuffer=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,this.frameBuffer),this.pbo=n.createBuffer(),[2]):[2]}))}))},o.prototype.createProgram=function(n){var o=this,e=n.op,t=n.outTensor,r=n.inputTensors,i=n.shaderParams,s=n.runtime,a=n.isFinalOp,u=null;try{var l=function(){for(var n=0,o=0,e=arguments.length;o<e;o++)n+=arguments[o].length;var t=Array(n),r=0;for(o=0;o<e;o++)for(var i=arguments[o],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}([t],r);l.forEach((function(n){return T.genTextureInfoFromTensorShape(o.MAX_TEXTURE_SIZE,n)}));var f=W(this.textureConf,e,l,i,s);(u=new z(this.gl,this.vShader,f,t)).fsCode=f;var c=F.genOutputTexture(this.gl,this.textureConf,t,a);this.texturesMap[t.tensorId]=c,this.program=u}catch(n){console.error(\"webgl createProgram: \"+e.name+\" -- \"+n)}return u},o.prototype.runProgram=function(n,o){var e=this,t=function(n,o){if(2===o){var e=n.getExtension(\"EXT_disjoint_timer_query_webgl2\");if(!e)return;var t=n.createQuery();return n.beginQuery(e.TIME_ELAPSED_EXT,t),t}return null}(this.gl,this.glVersion),r=n.isPackedOp;n.program.forEach((function(t,i){var s=n.outputTensors[i],a=s.tensorId;e.setOutProps(s),\"frameBuffer\"===n.bufferType?e.attachFrameBuffer(a):e.attachColorBuffer(),t.setProgram(e.gl,e.vertexBuffer,o),e.program=t,e.render(n,o,i,r)})),t&&(this.queryList.push({name:n.name,query:t,count:1}),t=function(n,o,e){if(2===o){var t=n.getExtension(\"EXT_disjoint_timer_query_webgl2\");if(!t)return;n.endQuery(t.TIME_ELAPSED_EXT)}return e}(this.gl,this.glVersion,t))},o.prototype.read=function(n){return Z(this,void 0,void 0,(function(){var o,e,t,r;return K(this,(function(i){switch(i.label){case 0:return f.get(\"webgl_gpu_pipeline\")?(o=this.gl,this.frameBuffer=o.createFramebuffer(),o.bindFramebuffer(o.FRAMEBUFFER,this.frameBuffer),[2,[]]):(e=this.createPBO(),[4,this.createAndWaitForFence()]);case 1:return i.sent(),t=this.downloadFloat32TensorFromBuffer(e),r=n?n.shape:[],f.get(\"webgl_pack_output\")?[2,t.slice(0,g(r))]:[2,t]}}))}))},o.prototype.createPBO=function(){var n,o=this.textureConf;if(2===this.glVersion){var e=this.gl,t=this.pbo;e.bindBuffer(e.PIXEL_PACK_BUFFER,t);var r=16*this.width_texture_out*this.height_texture_out;return e.bufferData(e.PIXEL_PACK_BUFFER,r,e.STREAM_READ),e.readPixels(0,0,this.width_texture_out,this.height_texture_out,e.RGBA,e.FLOAT,0),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),t}var i=this.gl,s=i.FLOAT;return o.isFloatTextureReadPixelsEnabled?n=new Float32Array(this.width_texture_out*this.height_texture_out*4):(n=new Uint8Array(this.width_texture_out*this.height_texture_out*4),s=i.UNSIGNED_BYTE),i.readPixels(0,0,this.width_texture_out,this.height_texture_out,i.RGBA,s,n),o.isFloatTextureReadPixelsEnabled?n:new Float32Array(n.buffer)},o.prototype.createAndWaitForFence=function(){return Z(this,void 0,void 0,(function(){var n,o,e,t,r=this;return K(this,(function(i){return n=this.gl,o=null!=n.fenceSync,e=function(){return!0},o&&(t=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0),n.flush(),e=function(){var o=n.clientWaitSync(t,0,0);return o===n.ALREADY_SIGNALED||o===n.CONDITION_SATISFIED}),[2,new Promise((function(n){r.pollItem(e,n)}))]}))}))},o.prototype.pollItem=function(n,o){var e=function(){n()?o():setTimeout(e,1)};e()},o.prototype.downloadFloat32TensorFromBuffer=function(n){var o=4*this.width_texture_out*this.height_texture_out;if(2===this.glVersion){var e=this.gl,t=new Float32Array(o);e.bindBuffer(e.PIXEL_PACK_BUFFER,n),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,t),e.bindBuffer(e.PIXEL_PACK_BUFFER,null);var r=[];if(f.get(\"webgl_pack_output\"))return Array.from(t);for(var i=0;i<this.width_texture_out*this.height_texture_out;i++)r.push(t[4*i]);return r}var s=n,a=[];for(i=0;i<this.width_texture_out*this.height_texture_out;i++){var u=this.textureConf.isFloatTextureReadPixelsEnabled?4*i:i;a.push(s[u])}return a},o.prototype.setOutProps=function(n){var o=n.width_shape,e=void 0===o?1:o,t=n.height_shape,r=void 0===t?1:t,i=n.width_texture,s=void 0===i?1:i,a=n.height_texture,u=void 0===a?1:a,l=n.channel,f=void 0===l?0:l,c=n.total_shape,_=void 0===c?0:c;this.width_shape_out=e,this.height_shape_out=r,this.width_texture_out=s,this.height_texture_out=u,this.channel=f,this.total_shape=_},o.prototype.attachColorBuffer=function(){var n=this.gl;n.bindFramebuffer(n.FRAMEBUFFER,null),n.canvas.width=this.width_shape_out,n.canvas.height=this.height_shape_out,n.viewport(0,0,n.canvas.width,n.canvas.height),n.scissor(0,0,n.canvas.width,n.canvas.height)},o.prototype.attachFrameBuffer=function(n){this.currentTexture=this.texturesMap[n];var o=this.gl;o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,this.currentTexture,0),o.viewport(0,0,this.width_texture_out,this.height_texture_out),o.scissor(0,0,this.width_texture_out,this.height_texture_out)},o.prototype.render=function(n,o,e,t){var r=this;void 0===o&&(o=!1),void 0===t&&(t=!1);var i=n.inputTensors,s=void 0===i?[]:i,a=n.uniform,u=void 0===a?null:a,l=n.iLayer,f=void 0===l?0:l,c=n.modelName,_=this.gl,g=0;s.forEach((function(n){r.initTexture(g,n,t);var i=r.getUniformLoc(\"texture_\"+n.name,f,o,e,c);i&&_.uniform1i(i,g++)})),u&&this.setUniform(u,f,o,e,c),_.drawArrays(_.TRIANGLE_STRIP,0,4)},o.prototype.initTexture=function(n,o,e){var t,r=this.gl,i=this.textureConf,s=o.tensorId,a=e||o.isPacked,u=o.data;if(o.persistable){this.cacheTextures=this.cacheTextures||{};var l=this.cacheTextures[s];l?(t=l,u&&T.genTextureInfoFromTensorShape(this.MAX_TEXTURE_SIZE,o)):(t=r.createTexture(),this.cacheTextures[s]=t)}else t=this.texturesMap[s];r.activeTexture(r[\"TEXTURE\"+n]),r.bindTexture(r.TEXTURE_2D,t),u&&(F.uploadDataToTexture(r,i,o,a),o.data=null)},o.prototype.setUniform=function(n,o,e,t,r){var i=this,s=Object.keys(n),a=this.gl;s.forEach((function(s){var u=n[s].type,l=n[s].value,f=i.getUniformLoc(s,o,e,t,r);T.setUniformParam(a,f,u,l)}))},o.prototype.getUniformLoc=function(n,o,e,t,r){var i=r+\"_\";if(e)return this.uniformLocations[i+o][n+t];var s=this.gl.getUniformLocation(this.program.program,n);return this.uniformLocations[i+o]=this.uniformLocations[i+o]||{},this.uniformLocations[i+o][n+t]=s,s},o.prototype.dispose=function(){},o}((function(){})),J={mainFunc:function(n,o){var e=n.origin,t=n.filter,r=n.out,i=n.bias,s=o.groups,a=void 0===s?1:s,u=o.strides,l=void 0===u?[]:u,f=o.paddings,c=void 0===f?[]:f,_=o.dilations,g=void 0===_?[]:_,h=o.fuse_relu,d=o.filter_nearest_vec4,p=o.filter_remainder_vec4,P=o.act_type,m=l[0],v=void 0===m?1:m,x=l[1],T=void 0===x?1:x,F=c[0],b=void 0===F?0:F,y=c[1],E=void 0===y?0:y,w=g[0],V=void 0===w?1:w,A=g[1],C=void 0===A?1:A;return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        int x = oPos.a;\\n        int c = oPos.g;\\n        int y = oPos.b;\\n        int b = oPos.r;\\n        float res = 0.0;\\n\\n        // 获取output的坐标\\n        int oTensorChannel = (c / (\"+r.channel+\" / \"+a+\")) * \"+t.channel+\";\\n        int oy = y * \"+v+\" - \"+b+\";\\n        for (int fy = 0; fy < \"+t.height_shape+\"; fy++) {\\n            if (oy >= \"+e.height_shape+\") {\\n                break;\\n            }\\n            if (oy < 0) {\\n                oy += \"+V+\";\\n                continue;\\n            }\\n            int ox = x * \"+T+\" - \"+E+\";\\n            for (int fx = 0; fx < \"+t.width_shape+\"; fx++) {\\n                if (ox >= \"+e.width_shape+\") {\\n                    break;\\n                }\\n                if (ox < 0) {\\n                    ox += \"+C+\";\\n                    continue;\\n                }\\n                // channel计算\\n                for (int j = 0; j < \"+d+\"; j += 4) {\\n                    vec4 fValues = vec4(\\n                        getValueFromTensorPos_filter(c, j, fy, fx),\\n                        getValueFromTensorPos_filter(c, j + 1, fy, fx),\\n                        getValueFromTensorPos_filter(c, j + 2, fy, fx),\\n                        getValueFromTensorPos_filter(c, j + 3, fy, fx)\\n                    );\\n\\n                    vec4 oValues = vec4(\\n                        getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox),\\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 1, oy, ox),\\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 2, oy, ox),\\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 3, oy, ox)\\n                      );\\n\\n                    res += dot(fValues, oValues);\\n                }\\n\\n                if (\"+p+\" == 1) {\\n                    res += dot(\\n                        getValueFromTensorPos_filter(c, \"+d+\", fy, fx),\\n                        getValueFromTensorPos_origin(b, oTensorChannel + \"+d+\", oy, ox));\\n                } else if (\"+p+\" == 2) {\\n                    vec2 fValues = vec2(\\n                        getValueFromTensorPos_filter(c, \"+d+\", fy, fx),\\n                        getValueFromTensorPos_filter(c, \"+d+\" + 1, fy, fx)\\n                    );\\n                    vec2 oValues = vec2(\\n                        getValueFromTensorPos_origin(b, oTensorChannel + \"+d+\", oy, ox),\\n                        getValueFromTensorPos_origin(b, oTensorChannel + \"+d+\" + 1, oy, ox)\\n                      );\\n                    res += dot(fValues, oValues);\\n                } else if (\"+p+\" == 3) {\\n                    vec3 fValues = vec3(\\n                        getValueFromTensorPos_filter(c, \"+d+\", fy, fx),\\n                        getValueFromTensorPos_filter(c, \"+d+\" + 1, fy, fx),\\n                        getValueFromTensorPos_filter(c, \"+d+\" + 2, fy, fx)\\n                    );\\n                    vec3 oValues = vec3(\\n                        getValueFromTensorPos_origin(b, oTensorChannel + \"+d+\", oy, ox),\\n                        getValueFromTensorPos_origin(b, oTensorChannel + \"+d+\" + 1, oy, ox),\\n                        getValueFromTensorPos_origin(b, oTensorChannel + \"+d+\" + 2, oy, ox)\\n                    );\\n                    res += dot(fValues, oValues);\\n                }\\n\\n                ox += \"+C+\";\\n            }\\n            oy += \"+V+\";\\n        }\\n\\n        \"+(i?\"res += getValueFromTensorPos_bias(0, 0, 0, c);\":\"\")+\"\\n\\n        if (\"+h+\") {\\n            res = max(0.0, res);\\n        }\\n        else if (\"+(\"relu6\"===P)+\") {\\n            res = min(max(0.0, res), 6.0);\\n        }\\n\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{filter:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"],bias:[\"getValueFromTensorPos\"]},behaviors:[\"adaptPaddings\",\"isApplySeparableConv\",\"batchComputeConv2d\",\"processBias\"]};function $(n,o){var e=n[0],t=n[1],r=n[2],i=n[3];if(1===e&&1===t)return[[1,1,r],3,[i],1,[r,i]];var s=n.slice(0,o),a=n.slice(o);return[s,s.length,a,a.length,[s.reduce((function(n,o){return n*o})),a.reduce((function(n,o){return n*o}))]]}function nn(n,o,e){if(1===e)return\"\\n            int getTensorPosFromArrayIndex_\"+n+\"(int n) {\\n                return calMod(n, \"+o[0]+\");\\n            }\\n        \";var t=_(o);return t.push(1),\"\\n    ivec\"+e+\" shapeVec_\"+n+\" = ivec\"+e+\"(\"+t.join(\", \")+\");\\n    ivec\"+e+\" getTensorPosFromArrayIndex_\"+n+\"(int n) {\\n        ivec\"+e+\" pos;\\n        pos[0] = n / shapeVec_\"+n+\"[0];\\n        for (int i = 1; i < \"+e+\"; i++) {\\n            n = calMod(n, shapeVec_\"+n+\"[i - 1]);\\n            pos[i] = n / shapeVec_\"+n+\"[i];\\n        }\\n        return pos;\\n    }\\n    \"}function on(n){return 1===n?\"int\":\"ivec\"+n}function en(n){var o=n.total_shape,e=n.channel,t=n.height_shape,r=n.width_shape;return[o/e/t/r,e,t,r]}const tn={mainFunc:function(n,o){var e=n.origin,t=o.transpose_X,r=void 0!==t&&t,i=o.transpose_Y,s=void 0!==i&&i,a=o.trans_x,u=void 0!==a&&a,l=o.trans_y,f=r||u,c=s||void 0!==l&&l;return\"\\n    void main() {\\n        float res = 0.0;\\n        // 获取output的坐标\\n        ivec4 out_pos = getOutputTensorPos();\\n        ivec4 origin_pos = out_pos;\\n        if (\"+f+\") {\\n            origin_pos[3] = origin_pos[2];\\n        }\\n        ivec4 counter_pos = out_pos;\\n        if (\"+c+\") {\\n            counter_pos[2] = counter_pos[3];\\n        }\\n\\n        for (int j = 0; j < \"+(f?e.height_shape:e.width_shape)+\"; j++) {\\n            if (\"+f+\") {\\n                origin_pos[2] = j;\\n            }\\n            else {\\n                origin_pos[3] = j;\\n            }\\n            if (\"+c+\") {\\n                counter_pos[3] = j;\\n            }\\n            else {\\n                counter_pos[2] = j;\\n            }\\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], origin_pos[2], origin_pos[3]);\\n            float c = getValueFromTensorPos_counter(counter_pos[0], counter_pos[1], counter_pos[2], counter_pos[3]);\\n            \\n            res += c * o;\\n        }\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{counter:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"]}};function rn(n,o){var e=n[0],t=n[1],r=n[2],i=n[3];if(1===e&&1===t)return[[1,1,r],3,[i],1,[r,i]];var s=n.slice(0,o),a=n.slice(o);return[s,s.length,a,a.length,[s.reduce((function(n,o){return n*o})),a.reduce((function(n,o){return n*o}))]]}function sn(n,o,e){if(1===e)return\"\\n            int getTensorPosFromArrayIndex_\"+n+\"(int n) {\\n                return calMod(n, \"+o[0]+\");\\n            }\\n        \";var t=_(o);return t.push(1),\"\\n    ivec\"+e+\" shapeVec_\"+n+\" = ivec\"+e+\"(\"+t.join(\", \")+\");\\n    ivec\"+e+\" getTensorPosFromArrayIndex_\"+n+\"(int n) {\\n        ivec\"+e+\" pos;\\n        pos[0] = n / shapeVec_\"+n+\"[0];\\n        for (int i = 1; i < \"+e+\"; i++) {\\n            n = calMod(n, shapeVec_\"+n+\"[i - 1]);\\n            pos[i] = n / shapeVec_\"+n+\"[i];\\n        }\\n        return pos;\\n    }\\n    \"}function an(n){return 1===n?\"int\":\"ivec\"+n}function un(n){var o=n.total_shape,e=n.channel,t=n.height_shape,r=n.width_shape;return[o/e/t/r,e,t,r]}const ln={mainFunc:function(n,o){return\"\\n    // start函数\\n    void main(void) {\\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\\n        int index = int(outCoord.x) + int(outCoord.y) * int(\"+n.out.width_texture+\");\\n        ivec4 originPos = getTensorPosFromArrayIndex_origin(index);\\n        float res = getValueFromTensorPos_origin(originPos[0], originPos[1], originPos[2], originPos[3]);\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{origin:[\"getTensorPosFromArrayIndex\",\"getValueFromTensorPos\"]}},fn={mainFunc:function(n,o){var e=n.out,t=n.origin,r=o.align_mode,i=void 0===r?1:r,s=o.align_corners,a=void 0===s||s;return\"\\n    // start函数\\n\\n    vec4 getData(float n, float scale, bool align_flag, int in_len) {\\n        float m = align_flag ? ((n + 0.5) / scale - 0.5) : (n / scale);\\n        int a1 = int(floor(m));\\n        a1 = a1 > 0 ? a1 : 0;\\n        int a2 = (a1 + 1) < (in_len - 1) ? (a1 + 1) : (in_len - 1);\\n\\n        float idx_src = (n + 0.5) / scale - 0.5;\\n        idx_src = idx_src > 0.0 ? idx_src : 0.0;\\n        float b1 = align_flag ? (idx_src - float(a1)) : (n / scale - float(a1));\\n        float b2 = 1.0 - b1;\\n        return vec4(float(a1), float(a2), b1, b2);\\n    }\\n\\n    void main(void) {\\n        // 输出数据\\n        ivec4 oPos = getOutputTensorPos();\\n\\n        bool align_flag = \"+i+\" == 0 && !\"+a+\";\\n\\n        float scale_x = 0.0;\\n        float scale_y = 0.0;\\n        if (\"+a+\") {\\n            scale_x = float(\"+e.width_shape+\" - 1) / float(\"+t.width_shape+\" - 1);\\n            scale_y = float(\"+e.height_shape+\" - 1) / float(\"+t.height_shape+\" - 1);\\n        }\\n        else {\\n            scale_x = float(\"+e.width_shape+\") / float(\"+t.width_shape+\");\\n            scale_y = float(\"+e.height_shape+\") / float(\"+t.height_shape+\");\\n        }\\n\\n        vec4 vx = getData(float(oPos.a), scale_x, align_flag, \"+t.width_shape+\");\\n        vec4 vy = getData(float(oPos.b), scale_y, align_flag, \"+t.height_shape+\");\\n\\n        int x1 = int(vx.r);\\n        int x2 = int(vx.g);\\n        float x3 = vx.b;\\n        float x4 = vx.a;\\n        int y1 = int(vy.r);\\n        int y2 = int(vy.g);\\n        float y3 = vy.b;\\n        float y4 = vy.a;\\n\\n        float value11 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x1);\\n        float value12 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x1);\\n        float value21 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x2);\\n        float value22 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x2);\\n        float value = x4 * y4 * value11 + x4 * y3 * value12 + x3 * y4 * value21 + x3 * y3 * value22;\\n        setOutput(float(value));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]}},cn=fn;var _n={relu:[\"transToPrelu\"],relu6:[\"transToRelu6\"],leaky_relu:[\"transToLeakyrelu\"],transToLeakyrelu:[\"transToLeakyrelu\"],scale:[\"transToScale\"],sigmoid:[\"transToSigmoid\"],hard_sigmoid:[\"transToHardSigmoid\"],pow:[\"transToPow\"],sqrt:[\"transToSqrt\"],tanh:[\"transToTanh\"]};function gn(n,o){var e=o.multi_value,t=void 0===e?1:e,r=o.bias_value,i=void 0===r?0:r;return\"\\n    // start函数\\n    void main(void) {\\n        // 输出数据\\n        float o = getPixelsFromTexturePos_origin(vCoord).r;\\n        float res = \"+o.active_function+\"(o, float(\"+t+\"), float(\"+i+\"));\\n        setOutput(res);\\n    }\\n    \"}function hn(n){return{mainFunc:gn,textureFuncConf:{origin:[\"getPixelsFromTexturePos\"]},behaviors:_n[n]}}const dn={mainFunc:function(n,o){var e=o.axes,t=Array.isArray(e)?e:[e],r=[0,1,2,3].filter((function(n){return n>=t.length}));return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        // 输出坐标转换为输入坐标\\n        float o = 0.0;\\n        o = getValueFromTensorPos_origin(\"+[0,1,2,3].map((function(n){return t.indexOf(n)>-1?0:\"oPos[\"+r.splice(0,1)+\"]\"})).join(\",\")+\");\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]}},pn={mainFunc:function(n,o){var e=n.origin,t=n.out,r=o.align_corners;return\"\\n    // start函数\\n    int getData(float n, float scale, bool align_corners) {\\n        float m = align_corners ? (n / scale + 0.5) : (n / scale);\\n        return int(floor(m));\\n    }\\n\\n    void main(void) {\\n        // 输出数据\\n        ivec4 oPos = getOutputTensorPos();\\n        \\n        float scale_x = 0.0;\\n        float scale_y = 0.0;\\n        if (\"+r+\") {\\n            scale_x = float(\"+t.width_shape+\" -1) / float(\"+e.width_shape+\" - 1);\\n            scale_y = float(\"+t.height_shape+\" - 1) / float(\"+e.height_shape+\" - 1);\\n        }\\n        else {\\n            scale_x = float(\"+t.width_shape+\") / float(\"+e.width_shape+\");\\n            scale_y = float(\"+t.height_shape+\") / float(\"+e.height_shape+\");\\n        }\\n    \\n        int vx = getData(float(oPos.a), scale_x, \"+r+\");\\n        int vy = getData(float(oPos.b), scale_y, \"+r+\");\\n        \\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, vy, vx);\\n        setOutput(float(o));\\n}\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]},commonFuncConf:[\"transferFromNHWCtoNCHW\"]};var Pn=function(){for(var n=0,o=0,e=arguments.length;o<e;o++)n+=arguments[o].length;var t=Array(n),r=0;for(o=0;o<e;o++)for(var i=arguments[o],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t};const mn={mainFunc:function(n,o){var e=n.origin,t=n.image,r=n.out,i=o.variances,s=void 0===i?[.1,.1,.2,.2]:i,a=o.fixed_sizes,u=o.fixed_ratios,l=o.densities,f=o.flatten_to_2d,c=o.clip,g=o.step_w,h=void 0===g?0:g,p=o.step_h,P=void 0===p?0:p,m=o.offset,v=void 0===m?.5:m,x=o.runtime,T=void 0===x?0:x,F=t.height_shape,b=t.width_shape,y=e.height_shape,E=e.width_shape,w=r.total_shape,V=r.channel,A=r.height_shape,C=r.width_shape,O=w/V/A/C,R=_([O,V,A,C]),S=h,I=P;0!==h&&0!==P||(S=b/E,I=F/y);var L=Math.round(.5*(S+I)),k=u.map((function(n){return Math.sqrt(n)})),B=1===k.length?\"sqrt_fixed_ratios\":\"sqrt_fixed_ratios[r]\",M=u.length,D=A,U=O,N=V;f&&(U=y,N=E,D=A/y/E);var G=_([U,N,D,C]),X=j(\"out1\",{numbers_shape:Pn(G,[1]),length_shape:4}),H=l.map((function(n){return n*n*M})),W=H.length,z=function(n){var o=\"ivec2 calRemain(int remain, int curAccIndex, int s) {\",e=n.length;if(1===e)o+=\"\\n            int accIndex0 = density_acc_shape;\\n\\n            if (remain >= accIndex0) {\\n                s++;\\n                remain -= accIndex0;\\n            }\\n            else {\\n                return ivec2(remain, s);\\n            }\\n            \";else for(var t=0;t<e;t++)o+=\"\\n            int accIndex\"+t+\" = density_acc_shape[\"+t+\"];\\n\\n            if (remain >= accIndex\"+t+\") {\\n                s++;\\n                remain -= accIndex\"+t+\";\\n            }\\n            else {\\n                return ivec2(remain, s);\\n            }\\n            \";return o+\"\\n    }\\n    \"}(H),q=c?\"v = min(max(v, 0.), 1.);\":\"\",Y=1===W?\"density_acc_shape\":\"density_acc_shape[0]\",Z=\"\\n    float getFloat4TensorVal(vec4 tensor, int index) {\\n        if (index == 0) {\\n            return tensor[0];\\n        }\\n        else if (index == 1) {\\n            return tensor[1];\\n        }\\n        else if (index == 2) {\\n            return tensor[2];\\n        }\\n        else if (index == 3) {\\n            return tensor[3];\\n        }\\n    }\\n    float getFloat3TensorVal(vec3 tensor, int index) {\\n        if (index == 0) {\\n            return tensor[0];\\n        }\\n        else if (index == 1) {\\n            return tensor[1];\\n        }\\n        else if (index == 2) {\\n            return tensor[2];\\n        }\\n    }\\n    float getFloat2TensorVal(vec2 tensor, int index) {\\n        if (index == 0) {\\n            return tensor[0];\\n        }\\n        else if (index == 1) {\\n            return tensor[1];\\n        }\\n    }\\n    float getFloat1TensorVal(float tensor, int index) {\\n        return tensor;\\n    }\\n    int getInt4TensorVal(ivec4 tensor, int index) {\\n        if (index == 0) {\\n            return tensor[0];\\n        }\\n        else if (index == 1) {\\n            return tensor[1];\\n        }\\n        else if (index == 2) {\\n            return tensor[2];\\n        }\\n        else if (index == 3) {\\n            return tensor[3];\\n        }\\n    }\\n    int getInt3TensorVal(ivec3 tensor, int index) {\\n        if (index == 0) {\\n            return tensor[0];\\n        }\\n        else if (index == 1) {\\n            return tensor[1];\\n        }\\n        else if (index == 2) {\\n            return tensor[2];\\n        }\\n    }\\n    int getInt2TensorVal(ivec2 tensor, int index) {\\n        if (index == 0) {\\n            return tensor[0];\\n        }\\n        else if (index == 1) {\\n            return tensor[1];\\n        }\\n    }\\n\\n    int getInt1TensorVal(int tensor, int index) {\\n       return tensor;\\n    }\\n\\n    \"+X+\"\\n    \\n        \"+d(l,\"densities\")+\"\\n        \"+d(a,\"fixed_sizes\")+\"\\n        \"+d(k,\"sqrt_fixed_ratios\")+\"\\n        \"+function(n,o){if(1===n.length)return\"int \"+o+\" = int(\"+n[0]+\");\";for(var e=n.length,t=\"\\n        ivec\"+e+\" \"+o+\" = ivec\"+e+\"(\\n    \",r=0;r<e;r++)t+=n[r]+\",\";return t.slice(0,-1)+\");\"}(H,\"density_acc_shape\")+\"\\n    \\n    \"+z+\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        int rr = int(oPos.r);\\n        int gg = int(oPos.g);\\n        int bb = int(oPos.b);\\n        int aa = int(oPos.a);\\n\\n        // 输出坐标转换为输入坐标\\n        int index = rr * \"+R[0]+\" + gg * \"+R[1]+\" + bb * \"+R[2]+\" + aa;\\n        ivec4 realOutPos = getTensorPosFromArrayIndex_out1(index);\\n        int h = realOutPos.r;\\n        int w = realOutPos.g;\\n        int b = realOutPos.b;\\n        int a = realOutPos.a;\\n    \";return 1===T?\"\\n        \"+d(s,\"variances\")+\"\\n        \"+Z+\"\\n        setOutput(getFloat4TensorVal(variances, aa));\\n        }\":\"\\n            \"+Z+\"\\n            // 求idx 对应的 s, r, di, dj\\n            int s = 0;\\n            int remain = b;\\n            int curAccIndex = \"+Y+\";\\n\\n            ivec2 remainInfo = calRemain(remain, curAccIndex, s);\\n            remain = remainInfo[0];\\n            s = remainInfo[1];\\n            int density = int(getFloat\"+l.length+\"TensorVal(densities, s));\\n            int r = int(floor(float(remain / density / density)));\\n            remain -= r * density * density;\\n\\n            float di = floor(float(remain / density));\\n            float dj = float(remain - int(di) * density);\\n\\n            float center_x = (float(w) + float(\"+v+\")) * float(\"+S+\");\\n            float center_y = (float(h) + float(\"+v+\")) * float(\"+I+\");\\n            float fixed_size = getFloat\"+a.length+\"TensorVal(fixed_sizes, s);\\n            float shift = float(\"+L+\") / float(density);\\n\\n            float v = 0.0;\\n            if (a == 0 || a == 2) {\\n                float box_width_ratio = fixed_size * \"+B+\";\\n                float density_center_x = center_x - float(\"+L+\") / 2. + shift / 2.;\\n                float center_x_temp = density_center_x + dj * shift;\\n                if (a == 0) {\\n                    v = max((center_x_temp - box_width_ratio / 2.) / float(\"+b+\"), 0.);\\n                }\\n                else {\\n                    v = min((center_x_temp + box_width_ratio / 2.) / float(\"+b+\"), 1.);\\n                }\\n            }\\n            else {\\n                float box_height_ratio = fixed_size / \"+B+\";\\n                float density_center_y = center_y - float(\"+L+\") / 2. + shift / 2.;\\n                float center_y_temp = density_center_y + di * shift;\\n                if (a == 1) {\\n                    v = max((center_y_temp - box_height_ratio / 2.) / float(\"+F+\"), 0.);\\n                }\\n                else {\\n                    v = min((center_y_temp + box_height_ratio / 2.) / float(\"+F+\"), 1.);\\n                }\\n            }\\n\\n            \"+q+\"\\n\\n            setOutput(v);\\n        }\\n        \"},textureFuncConf:{image:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"]}},vn={mainFunc:function(n,o){var e=n.origin,t=n.image,r=n.out,i=o.variances,s=void 0===i?[.1,.1,.2,.2]:i,a=o.flip,u=o.clip,l=o.step_w,f=void 0===l?0:l,c=o.step_h,_=void 0===c?0:c,g=o.offset,p=void 0===g?.5:g,P=o.runtime,m=void 0===P?0:P,v=o.min_sizes,x=void 0===v?[]:v,T=o.max_sizes,F=void 0===T?[]:T,b=o.aspect_ratios,y=void 0===b?[]:b,E=o.min_max_aspect_ratios_order,w=void 0!==E&&E,V=t.height_shape,A=t.width_shape,C=e.height_shape,O=e.width_shape,R=r.channel,S=r.height_shape,I=f,L=_;0!==f&&0!==_||(I=A/O,L=V/C);var k=[1];y.forEach((function(n){1!==n&&(k.push(Math.sqrt(n)),a&&k.push(Math.sqrt(1/n)))}));var B=k.length,M=u?\"res = min(max(res, 0.), 1.);\":\"\",D=\"\\n    float getFloat4TensorVal(vec4 tensor, int index) {\\n        if (index == 0) {\\n            return tensor[0];\\n        }\\n        else if (index == 1) {\\n            return tensor[1];\\n        }\\n        else if (index == 2) {\\n            return tensor[2];\\n        }\\n        else if (index == 3) {\\n            return tensor[3];\\n        }\\n    }\\n\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        int nn = int(oPos.r);\\n        int cc = int(oPos.g);\\n        int hh = int(oPos.b);\\n        int ww = int(oPos.a);\\n\\n\\n        \\n        \"+h(x,\"min_sizes\")+\"\\n        \"+h(F,\"max_sizes\")+\"\\n        \"+h(k,\"aspect_ratios\")+\"\\n    \\n\\n    \";return 1===m?\"\\n            \"+d(s,\"variances\")+\"\\n            \"+D+\"\\n            float res = 0.0;\\n            res = getFloat4TensorVal(variances, ww);\\n            setOutput(float(res));\\n        }\":\"\\n            \"+D+\"\\n            int idx = nn * \"+R*S+\" + cc * \"+S+\" + hh;\\n            int as_num = \"+B+\";\\n            float offset = \"+p+\";\\n            \\n            int feature_width = \"+O+\";\\n            int num_priors = \"+S+\";\\n            float step_width = float(\"+I+\");\\n            float step_height = float(\"+L+\");\\n\\n            float im_width = float(\"+A+\");\\n            float im_height = float(\"+V+\");\\n\\n            bool min_max_aspect_ratios_order = \"+w+\";\\n\\n            // 求idx 对应的 h w p m\\n            int h = int(idx / (num_priors * feature_width));\\n            int w = (idx / num_priors) % feature_width;\\n            int p = idx % num_priors;\\n            int m = \"+(F.length>0)+\" ? int(p / (as_num + 1)) : int(p / as_num);\\n            float cx = (float(w) + offset) * step_width;\\n            float cy = (float(h) + offset) * step_height;\\n            float min_size = float(min_sizes[m]);\\n            float bw = 0.0;\\n            float bh = 0.0;\\n\\n            \"+(F.length>0?\"\\n            int s = p % (as_num + 1);\\n            if (\"+!w+\") {\\n                if (s < as_num) {\\n                    float ar = aspect_ratios[s];\\n                    bw = min_size * ar / 2.0;\\n                    bh = min_size / ar / 2.0;\\n                }\\n                else {\\n                    float max_size = float(max_sizes[m]);\\n                    bw = sqrt(min_size * max_size) / 2.0;\\n                    bh = bw;\\n                }\\n            }\\n            else {\\n                if (s == 0) {\\n                    bh = min_size / 2.0;\\n                    bw = bh;\\n                }\\n                else if (s == 1) {\\n                    float max_size = float(max_sizes[m]);\\n                    bw = sqrt(min_size * max_size) / 2.0;\\n                    bh = bw;\\n                }\\n                else {\\n                    float ar = aspect_ratios[s - 1];\\n                    bw = min_size * sqrt(ar) / 2.0;\\n                    bh = min_size / sqrt(ar) / 2.0;\\n                }\\n            }\":\"\\n            int s = p % as_num;\\n            float ar = aspect_ratios[s];\\n            bw = min_size * ar / 2.0;\\n            bh = min_size / ar / 2.0;\\n        \")+\"\\n            float res = 0.0;\\n            if (ww == 0) {\\n                res = (cx - bw) / im_width;\\n            }\\n            else if (ww == 1) {\\n                res = (cy - bh) / im_height;\\n            }\\n            else if (ww == 2) {\\n                res = (cx + bw) / im_width;\\n            }\\n            else {\\n                res = (cy + bh) / im_height;\\n            }\\n\\n            \"+M+\"\\n\\n            setOutput(float(res));\\n        }\\n        \"},textureFuncConf:{image:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"]},behaviors:[]};var xn={arg_max:{mainFunc:function(n,o){var e=n.origin,t=o.axis,r=void 0===t?-1:t,i=o.flatten,s=e.total_shape,a=e.height_shape,u=e.width_shape,l=e.channel,f=e.length_unformatted_shape,c=s/(u*a*l),_=r<0?3:4-f+r,g=[c,l,a,u][_];return\"\\n\\n    void main() {\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = 0.0;\\n        int pos = 0;\\n        if (\"+!i+\") {\\n            if (\"+_+\" == 1) {\\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\\n                for (int index = 0; index < \"+g+\"; index++) {\\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\\n                    if (o > tmp) {\\n                        tmp = o;\\n                        pos = index;\\n                    }\\n                }\\n            }\\n            else if (\"+_+\" == 2) {\\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\\n                for (int index = 0; index < \"+g+\"; index++) {\\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\\n                    if (o > tmp) {\\n                        tmp = o;\\n                        pos = index;\\n                    }\\n                }\\n            }\\n            else if (\"+_+\" == 3) {\\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\\n                for (int index = 0; index < \"+g+\"; index++) {\\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\\n                    if (o > tmp) {\\n                        tmp = o;\\n                        pos = index;\\n                    }\\n                }\\n            }\\n            else {\\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\\n                for (int index = 0; index < \"+g+\"; index++) {\\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\\n                    if (o > tmp) {\\n                        tmp = o;\\n                        pos = index;\\n                    }\\n                }\\n            }\\n        }\\n        else {\\n            int index = 0;\\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\\n            for (int n = 0; n < \"+c+\"; n++) {\\n                for (int c = 0; c < \"+l+\"; c++) {\\n                    for (int h = 0; h < \"+a+\"; h++) {\\n                        for (int w = 0; w < \"+u+\"; w++) {\\n                            o = getValueFromTensorPos_origin(n, c, h, w);\\n                            if (o > tmp) {\\n                                tmp = o;\\n                                pos = index;\\n                            }\\n                            index++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        setOutput(float(pos));\\n    }\"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]}},arg_min:{mainFunc:function(n,o){for(var e=n.origin,t=o.axis,r=void 0===t?-1:t,i=o.flatten,s=e.total_shape,a=e.height_shape,u=e.width_shape,l=e.channel,f=s/(u*a*l),c=[f,l,a,u],_=0,g=0;g<4&&!(c[g]>1);g++)_++;var h=r<0?4-_+r:r,d=c[h=_+h];return\"\\n    void main() {\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = 0.0;\\n        int pos = 0;\\n        if (\"+!i+\") {\\n            if (\"+h+\" == 1) {\\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\\n                for (int index = 0; index < \"+d+\"; index++) {\\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\\n                    if (o < tmp) {\\n                        tmp = o;\\n                        pos = index;\\n                    }\\n                }\\n            }\\n            else if (\"+h+\" == 2) {\\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\\n                for (int index = 0; index < \"+d+\"; index++) {\\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\\n                    if (o < tmp) {\\n                        tmp = o;\\n                        pos = index;\\n                    }\\n                }\\n            }\\n            else if (\"+h+\" == 3) {\\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\\n                for (int index = 0; index < \"+d+\"; index++) {\\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\\n                    if (o < tmp) {\\n                        tmp = o;\\n                        pos = index;\\n                    }\\n                }     \\n            }\\n            else {\\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\\n                for (int index = 0; index < \"+d+\"; index++) {\\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\\n                    if (o < tmp) {\\n                        tmp = o;\\n                        pos = index;\\n                    }\\n                }\\n            }\\n        }\\n        else {\\n            int index = 0;\\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\\n            for (int n = 0; n < \"+f+\"; n++) {\\n                for (int c = 0; c < \"+l+\"; c++) {\\n                    for (int h = 0; h < \"+a+\"; h++) {\\n                        for (int w = 0; w < \"+u+\"; w++) {\\n                            o = getValueFromTensorPos_origin(n, c, h, w);\\n                            if (o < tmp) {\\n                                tmp = o;\\n                                pos = index;\\n                            }\\n                            index++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        setOutput(float(pos));\\n    }\"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]}},conv2d:J,conv2d_packing:{mainFunc:function(n,o){var e=n.origin,t=n.filter,r=n.out,i=n.bias,s=o.groups,a=void 0===s?1:s,u=o.strides,l=void 0===u?[]:u,f=o.paddings,c=void 0===f?[]:f,_=o.dilations,g=void 0===_?[]:_,h=o.fuse_relu,d=o.act_type,p=l[0],P=void 0===p?1:p,m=l[1],v=void 0===m?1:m,x=c[0],T=void 0===x?0:x,F=c[1],b=void 0===F?0:F,y=g[0],E=void 0===y?1:y,w=g[1],V=void 0===w?1:w;return\"\\n    void main() {\\n        ivec4 oPos = getOutputTensorPos();\\n        int x = oPos.a;\\n        int c = oPos.g;\\n        int y = oPos.b;\\n        int b = oPos.r;\\n        vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\\n\\n        int oy = y * \"+P+\" - \"+T+\";\\n        for (int fy = 0; fy < \"+t.height_shape+\"; fy++) {\\n            if (oy >= \"+e.height_shape+\") {\\n                break;\\n            }\\n            if (oy < 0) {\\n                oy += \"+E+\";\\n                continue;\\n            }\\n            int ox = x * \"+v+\" - \"+b+\";\\n            for (int fx = 0; fx < \"+t.width_shape+\"; fx++) {\\n                if (ox >= \"+e.width_shape+\") {\\n                    break;\\n                }\\n                if (ox < 0) {\\n                    ox += \"+V+\";\\n                    continue;\\n                }\\n                // channel计算\\n                for (int j = 0; j < \"+t.channel+\"; j += 1) {\\n                    int c0 = (c / (\"+r.channel+\" * 4 / \"+a+\")) * \"+t.channel+\" + j;\\n                    vec4 fValue = getValueFromTensorPosPacking_filter(c * 4, j, fy, fx);\\n                    vec4 oValue = getValueFromTensorPosPacking_origin(b, c0, oy, ox);\\n\\n                    for (int packed_index = 0; packed_index < 4; packed_index++) {\\n                        if (packed_index == 0) {\\n                            res.r += dot(fValue, oValue);\\n                        } else if (packed_index == 1) {\\n                            int c1 = ((c + 1) / (\"+r.channel+\" * 4 / \"+a+\")) * \"+t.channel+\" + j;\\n                            oValue = getValueFromTensorPosPacking_origin(b, c1, oy, ox);\\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 1, j, fy, fx);\\n                            res.g += dot(fValue, oValue);\\n                        } else if (packed_index == 2) {\\n                            int c2 = ((c + 2) / (\"+r.channel+\" * 4 / \"+a+\")) * \"+t.channel+\" + j;\\n                            oValue = getValueFromTensorPosPacking_origin(b, c2, oy, ox);\\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 2, j, fy, fx);\\n                            res.b += dot(fValue, oValue);\\n                        } else if (packed_index == 3) {\\n                            int c3 = ((c + 3) / (\"+r.channel+\" * 4 / \"+a+\")) * \"+t.channel+\" + j;\\n                            oValue = getValueFromTensorPosPacking_origin(b, c3, oy, ox);\\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 3, j, fy, fx);\\n                            res.a += dot(fValue, oValue);\\n                        }\\n                    }\\n                }\\n                ox += \"+V+\";\\n            }\\n            oy += \"+E+\";\\n        }\\n\\n        \"+(i?\"res += getValueFromTensorPosPacking_bias(0, c, 0, 0);\":\"\")+\"\\n\\n        if (\"+h+\") {\\n            res = max(vec4(0.0, 0.0, 0.0, 0.0), res);\\n        }\\n        else if (\"+(\"relu6\"===d)+\") {\\n            res = min(max(vec4(0.0, 0.0, 0.0, 0.0), res), vec4(6.0, 6.0, 6.0, 6.0));\\n        }\\n        setPackedOutput(res);\\n    }\\n    \"},textureFuncConf:{filter:[\"getValueFromTensorPosPacking\"],origin:[\"getValueFromTensorPosPacking\"],bias:[\"getValueFromTensorPosPacking\"]},behaviors:[\"adaptPaddings\",\"isApplySeparableConv\",\"batchComputeConv2d\",\"processBias\"]},conv2d_transpose:{mainFunc:function(n,o){var e=n.origin,t=n.filter,r=n.out,i=o.groups,s=void 0===i?1:i,a=o.strides,u=void 0===a?[]:a,l=o.paddings,f=void 0===l?[]:l,c=o.dilations,_=void 0===c?[]:c,g=u[0],h=void 0===g?1:g,d=u[1],p=void 0===d?1:d,P=f[0],m=void 0===P?0:P,v=f[1],x=void 0===v?0:v;x=t.height_shape-x-1,m=t.width_shape-m-1;var T=_[0],F=void 0===T?1:T,b=_[1],y=void 0===b?1:b;return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        int x = oPos.a;\\n        int c = oPos.g;\\n        int y = oPos.b;\\n        int b = oPos.r;\\n        float res = 0.0;\\n        int temp_x = 0;\\n        int temp_y = 0;\\n        float o = 0.0;\\n        float f = 0.0;\\n\\n        // 获取output的坐标\\n        int oTensorChannel = int(c * \"+s+\" / \"+r.channel+\") * \"+e.channel+\";\\n        int oy = y - \"+x+\";\\n        const int groupLen = int(\"+e.channel+\" / \"+s+\");\\n        int groupIndex = int(c / groupLen);\\n\\n        for (int fy = 0; fy < \"+t.height_shape+\"; fy++) {\\n            if (oy < 0) {\\n                oy += \"+F+\";\\n                continue;\\n            }\\n            int ox = x - \"+m+\";\\n            for (int fx = 0; fx < \"+t.width_shape+\"; fx++) {\\n\\n                if (ox < 0) {\\n                    ox += \"+y+\";\\n                    continue;\\n                }\\n                // channel计算\\n                for (int j = 0; j < groupLen; j++) {\\n                    int curIndex = j + b * groupLen;\\n                    if (calMod(ox, int(\"+p+\")) == 0 && calMod(oy, int(\"+h+\")) == 0) {\\n                        temp_x = int(floor(float(ox) / float(\"+p+\")));\\n                        temp_y = int(floor(float(oy) / float(\"+h+\")));\\n                        if (temp_x < \"+e.width_shape+\" && temp_y < \"+e.height_shape+\") {\\n                            o = getValueFromTensorPos_origin(b, curIndex , temp_y, temp_x);\\n                            f = getValueFromTensorPos_filter(\\n                                curIndex,\\n                                int(c / \"+s+\"),\\n                                \"+t.height_shape+\"-1-fy,\\n                                \"+t.width_shape+\"-1-fx\\n                            );\\n                            res += f * o;\\n                        }\\n                    }\\n                }\\n                ox += \"+y+\";\\n            }\\n            oy += \"+F+\";\\n        }\\n        setOutput(float(res));\\n    }\\n\"},textureFuncConf:{filter:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"]},behaviors:[\"adaptPaddings\",\"isApplySeparableConv\",\"batchComputeConv2d\",\"processBias\"]},depthwise_conv2d:J,conv2d_depthwise:J,conv2d_elementwise_add:{mainFunc:function(n,o){var e=n.origin,t=n.filter,r=n.out,i=n.counter,s=o.active_function,a=o.groups,u=void 0===a?1:a,l=o.axis,f=o.strides,c=void 0===f?[]:f,_=o.paddings,g=void 0===_?[]:_,h=o.dilations,d=void 0===h?[]:h,p=o.multi_value,P=o.bias_value,m=c[0],v=void 0===m?1:m,x=c[1],T=void 0===x?1:x,F=g[0],b=void 0===F?0:F,y=g[1],E=void 0===y?0:y,w=d[0],V=void 0===w?1:w,A=d[1],C=void 0===A?1:A;return\"\\n    // start函数\\n\\n    float getValueFromCounter(int index) {\\n        float xPos = float(index) / float(\"+i.width_shape+\");\\n        vec4 pixels = TEXTURE2D(texture_counter, vec2(xPos, 0.5));\\n        return pixels.r;\\n    }\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n\\n        int x = oPos.a;\\n        int c = oPos.g;\\n        int y = oPos.b;\\n        int b = oPos.r;\\n        int addAxis = oPos[\"+l+\"];\\n        float res = getValueFromCounter(addAxis);\\n\\n        // 获取output的坐标\\n        int oTensorChannel = (c / (\"+r.channel+\" / \"+u+\")) * \"+t.channel+\";\\n        int oy = y * \"+v+\" - \"+b+\";\\n        for (int fy = 0; fy < \"+t.height_shape+\"; fy++) {\\n            if (oy >= \"+e.height_shape+\") {\\n                break;\\n            }\\n            if (oy < 0) {\\n                oy += \"+V+\";\\n                continue;\\n            }\\n            int ox = x * \"+T+\" - \"+E+\";\\n            for (int fx = 0; fx < \"+t.width_shape+\"; fx++) {\\n                if (ox >= \"+e.width_shape+\") {\\n                    break;\\n                }\\n                if (ox < 0) {\\n                    ox += \"+C+\";\\n                    continue;\\n                }\\n                // channel计算\\n                for (int j = 0; j < \"+t.channel+\"; j++) {\\n                    float f = getValueFromTensorPos_filter(c, j, fy, fx);\\n                    float o = getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox);\\n                    res += f * o;\\n                }\\n                ox += \"+C+\";\\n            }\\n            oy += \"+V+\";\\n        }\\n        setOutput(\"+s+\"(res,  \"+p+\",  \"+P+\"));\\n    }\\n\"},textureFuncConf:{filter:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"],counter:[\"getValueFromTensorPos\"]},behaviors:[\"mergeAttrs\",\"checkIsMerge\",\"setActiveFunc\"]},pool2d:{mainFunc:function(n,o){var e=n.origin,t=o.strides,r=void 0===t?[]:t,i=o.paddings,s=void 0===i?[]:i,a=o.pooling_type,u=o.ksize,l=r[0],f=void 0===l?1:l,c=r[1],_=void 0===c?1:c,g=s[0],h=void 0===g?0:g,d=s[1],p=void 0===d?0:d,P=u[0],m=u[1];return\"\\n    // start函数\\n    void main(void) {\\n        float res = 0.0;\\n        if (\"+a+\" == 1) {\\n            res = -1.70141184e38;\\n        }\\n        // 获取output的坐标\\n        ivec4 out_pos = getOutputTensorPos();\\n        // X、Y方向的移动步长\\n        int count_pool = 0;\\n        int oy_base = out_pos[2] * \"+f+\" - \"+h+\";\\n        int ox_base = out_pos[3] * \"+_+\" - \"+p+\";\\n        for (int fy = 0; fy < \"+P+\"; fy++) {\\n            int oy = oy_base + fy;\\n            if (oy >= \"+e.height_shape+\") {\\n                break;\\n            }\\n            if (oy < 0) {\\n                continue;\\n            }\\n            for (int fx = 0; fx < \"+m+\"; fx++) {\\n                int ox = ox_base + fx;\\n                if (ox >= \"+e.width_shape+\") {\\n                    break;\\n                }\\n                if (ox < 0) {\\n                    continue;\\n                }\\n                // origin数据\\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\\n                if (\"+a+\" == 1) {\\n                    if (curr > res) {\\n                        res = curr;\\n                    }\\n                } else {\\n                    res += curr;\\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\\n                    count_pool++;\\n                }\\n            }\\n        }\\n        if (\"+a+\" != 1) {\\n            res = res / float(count_pool);\\n        }\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]},behaviors:[\"isMax\",\"setPacked\",\"isGlobalPooling\"]},pool2d_max:{mainFunc:function(n,o){var e=n.origin,t=o.strides,r=void 0===t?[]:t,i=o.paddings,s=void 0===i?[]:i,a=o.ksize,u=o.global_pooling,l=o.runtime,f=r[0],c=void 0===f?1:f,_=r[1],g=void 0===_?1:_,h=s[0],d=void 0===h?0:h,p=s[1],P=void 0===p?0:p,m=a[0],v=a[1],x=function(n){var o=n.total_shape,e=n.channel,t=n.height_shape,r=n.width_shape;return[o/e/t/r,e,t,r]}(e),T=\"\",F=\"setOutput(float(res));\";return 0===l&&!0===u&&(T=\"\\n            if (curr > res) {\\n                index = \"+x[2]*x[3]+\" * out_pos[1] + \"+x[3]+\" * oy + ox;\\n            }\\n        \",F=\"setOutput(float(index));\"),\"\\n    // start函数\\n    void main(void) {\\n        float res = -1.70141184e38;\\n        int index = 0;\\n        // 获取output的坐标\\n        ivec4 out_pos = getOutputTensorPos();\\n        int b = out_pos[0];\\n        int c = out_pos[1];\\n        int y = out_pos[2];\\n        int x = out_pos[3];\\n        // X、Y方向的移动步长\\n        int oy_base = out_pos[2] * \"+c+\" - \"+d+\";\\n        int ox_base = out_pos[3] * \"+g+\" - \"+P+\";\\n        for (int fy = 0; fy < \"+m+\"; fy++) {\\n            int oy = oy_base + fy;\\n            if (oy >= \"+e.height_shape+\") {\\n                break;\\n            }\\n            if (oy < 0) {\\n                continue;\\n            }\\n            for (int fx = 0; fx < \"+v+\"; fx++) {\\n                int ox = ox_base + fx;\\n                if (ox >= \"+e.width_shape+\") {\\n                    break;\\n                }\\n                if (ox < 0) {\\n                    continue;\\n                }\\n                // origin数据\\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\\n                \"+T+\"\\n                res = max(res, curr);\\n            }\\n        }\\n        \"+F+\"\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]},behaviors:[\"isMax\",\"setPacked\",\"setAdaptive\",\"isGlobalPooling\"]},pool2d_winograd:{mainFunc:function(n,o){var e=n.origin,t=n.pool,r=o.strides,i=void 0===r?[]:r,s=o.paddings,a=void 0===s?[]:s,u=o.type_pool,l=i[0],f=void 0===l?1:l,c=i[1],_=void 0===c?1:c,g=a[0],h=void 0===g?0:g,d=a[1],p=void 0===d?0:d,P=e.height_shape,m=e.width_texture,v=e.height_texture;return\"\\n\\n    float getValueFromTensorPosPacked_origin(int r, int g, int b, int a) {\\n        int y = b / 2;\\n        int yOffset = calMod(b, 2);\\n        int x = a / 2;\\n        int xOffset = calMod(a, 2);\\n        int height = \"+P+\" + \"+e.offset_y+\";\\n        vec4 pixels = TEXTURE2D(\\n            texture_origin,\\n            vec2((float(x) + 0.5) / float(\"+m+\"),\\n            (float(g * height / 2 + y) + 0.5) / float(\"+v+\"))\\n        );\\n        int index = 0;\\n        if (xOffset == 0 && yOffset == 0) {\\n            return pixels[0];\\n        }\\n        else if (xOffset == 1 && yOffset == 0) {\\n            return pixels[1];\\n        }\\n        else if (xOffset == 0 && yOffset == 1) {\\n            return pixels[2];\\n        }\\n        return pixels[3];\\n    }\\n\\n    // start函数\\n    void main(void) {\\n        float res = (-1.0 / exp(-20.0));\\n        // 获取output的坐标\\n        ivec4 out_pos = getOutputTensorPos();\\n        // int b = out_pos[0];\\n        // int c = out_pos[1];\\n        // int y = out_pos[2];\\n        // int x = out_pos[3];\\n        // X、Y方向的移动步长\\n        int count_pool = 0;\\n        int oy_base = out_pos[2] * \"+f+\" - \"+h+\";\\n        int ox_base = out_pos[3] * \"+_+\" - \"+p+\";\\n\\n        for (int fy = 0; fy < \"+t.height_shape+\"; fy++) {\\n            int oy = oy_base + fy;\\n            if (oy >= \"+e.height_shape+\") {\\n                break;\\n            }\\n            if (oy < 0) {\\n                continue;\\n            }\\n            for (int fx = 0; fx < \"+t.width_shape+\"; fx++) {\\n                int ox = ox_base + fx;\\n                if (ox >= \"+e.width_shape+\") {\\n                    break;\\n                }\\n                if (ox < 0) {\\n                    continue;\\n                }\\n                // origin数据\\n                float curr = getValueFromTensorPosPacked_origin(out_pos[0], out_pos[1], oy, ox);\\n                if (\"+u+\" == 1) {\\n                    if (curr > res) {\\n                        res = curr;\\n                    }\\n                } else {\\n                    res += curr;\\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\\n                    count_pool++;\\n                }\\n            }\\n        }\\n        if (\"+u+\" != 1) {\\n            res = res / float(count_pool);\\n        }\\n        setOutput(res);\\n    }\\n    \"},behaviors:[\"isMax\",\"setPacked\",\"isGlobalPooling\"]},elementwise_add:{mainFunc:function(n,o){var e=o.counterPos,t=o.Scale_y,r=void 0===t?1:t,i=o.Scale_x,s=void 0===i?1:i,a=o.Scale_out,u=void 0===a?1:a;return\"\\n    void main(void) {\\n        // 输出数据\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n\\n        float c = getValueFromTensorPos_counter(\"+e+\");\\n        float res = float(\"+u/r+\") * c + float(\"+u/s+\") * o;\\n        setOutput(float(res));\\n    }\\n    \"},textureFuncConf:{counter:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"]},behaviors:[\"processElementwiseAxis\",\"genElementwiseCounterPos\"]},elementwise_mul:{mainFunc:function(n,o){var e=n.counter,t=o.counterPos,r=o.Scale_y,i=void 0===r?1:r,s=o.Scale_x,a=void 0===s?1:s,u=o.Scale_out,l=void 0===u?1:u;return\"\\n    ivec4 formatNCHW(int n, int c, int h, int w) {\\n        int newN = n;\\n        int newC = c;\\n        int newH = h;\\n        int newW = w;\\n\\n        if (n >= \"+e.height_texture/e.height_shape+\") {\\n            newN = int(\"+e.height_texture/e.height_shape+\");\\n        }\\n        if (c >= \"+e.channel+\") {\\n            newC = int(\"+(e.channel-1)+\");\\n        }\\n        if (h >= \"+e.height_shape+\") {\\n            newH = \"+(e.height_shape-1)+\";\\n        }\\n        if (w >= \"+e.width_shape+\") {\\n            newW = \"+(e.width_shape-1)+\";\\n        }\\n        return ivec4(newN, newC, newH, newW);\\n    }\\n\\n    // start函数\\n    void main() {\\n        // 输出数据\\n        ivec4 oPos1 = getOutputTensorPos();\\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\\n\\n        float c = getValueFromTensorPos_counter(\"+t+\");\\n        float res = float(\"+l/a+\") * o * float(\"+1/i+\") * c;\\n        setOutput(float(res));\\n    }\\n\\n    \"},textureFuncConf:{counter:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"]},behaviors:[\"processElementwiseAxis\",\"genElementwiseCounterPos\"]},elementwise_div:{mainFunc:function(n,o){var e=n.counter,t=o.counterPos,r=o.Scale_y,i=void 0===r?1:r,s=o.Scale_x,a=void 0===s?1:s,u=o.Scale_out,l=void 0===u?1:u;return\"\\n    ivec4 formatNCHW(int n, int c, int h, int w) {\\n        int newN = n;\\n        int newC = c;\\n        int newH = h;\\n        int newW = w;\\n\\n        if (n >= \"+e.height_texture/e.height_shape+\") {\\n            newN = int(\"+e.height_texture/e.height_shape+\");\\n        }\\n        if (c >= \"+e.channel+\") {\\n            newC = int(\"+(e.channel-1)+\");\\n        }\\n        if (h >= \"+e.height_shape+\") {\\n            newH = \"+(e.height_shape-1)+\";\\n        }\\n        if (w >= \"+e.width_shape+\") {\\n            newW = \"+(e.width_shape-1)+\";\\n        }\\n        return ivec4(newN, newC, newH, newW);\\n    }\\n\\n    // start函数\\n    void main() {\\n        // 输出数据\\n        ivec4 oPos1 = getOutputTensorPos();\\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\\n\\n        float c = getValueFromTensorPos_counter(\"+t+\");\\n        float res = float(\"+l+\") * (float(\"+1/a+\") * o / (float(\"+1/i+\") * c));\\n        setOutput(float(res));\\n    }\\n\\n    \"},textureFuncConf:{counter:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"]},behaviors:[\"processElementwiseAxis\",\"genElementwiseCounterPos\"]},elementwise_pow:{mainFunc:function(n,o){var e=o.counterPos,t=o.Scale_y,r=void 0===t?1:t,i=o.Scale_x,s=void 0===i?1:i,a=o.Scale_out,u=void 0===a?1:a;return\"\\n    void main(void) {\\n        // 输出数据\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n\\n        float c = getValueFromTensorPos_counter(\"+e+\");\\n        float res = pow(float(\"+u/s+\") * o, float(\"+u/r+\") * c);\\n        setOutput(float(res));\\n    }\\n    \"},textureFuncConf:{counter:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"]},behaviors:[\"processElementwiseAxis\",\"genElementwiseCounterPos\"]},elementwise_sub:{mainFunc:function(n,o){var e=o.counterPos,t=o.Scale_y,r=void 0===t?1:t,i=o.Scale_x,s=void 0===i?1:i,a=o.Scale_out,u=void 0===a?1:a;return\"\\n    void main(void) {\\n        // 输出数据\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n\\n        float c = getValueFromTensorPos_counter(\"+e+\");\\n        float res = float(\"+u/s+\") * o - float(\"+u/r+\") * c;\\n        setOutput(float(res));\\n    }\\n    \"},textureFuncConf:{counter:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"]},behaviors:[\"processElementwiseAxis\",\"genElementwiseCounterPos\"]},mul:{mainFunc:function(n,o){var e=n.origin,t=n.counter,r=o.x_num_col_dims,i=o.y_num_col_dims,s=en(e),a=en(t),u=$(s,r),l=u[0],f=u[1],c=u[2],_=u[3],g=u[4],h=$(a,i),d=h[0],p=h[1],P=h[2],m=h[3];return\"\\n    \"+nn(\"x1\",l,f)+\"\\n    \"+nn(\"x2\",c,_)+\"\\n    \"+nn(\"y1\",d,p)+\"\\n    \"+nn(\"y2\",P,m)+\"\\n\\n    // start函数\\n    void main(void) {\\n        float res = 0.0;\\n        // 获取output的坐标\\n        ivec4 opos = getOutputTensorPos();\\n        float temp = 0.0;\\n\\n        // output is 2D\\n        int b = opos.b;\\n        int a = opos.a;\\n\\n        \"+on(f)+\" x1 = getTensorPosFromArrayIndex_x1(b);\\n        \"+on(m)+\" y2 = getTensorPosFromArrayIndex_y2(a);\\n\\n        for (int j = 0; j < \"+g[1]+\"; j++) {\\n            \"+on(_)+\" x2 = getTensorPosFromArrayIndex_x2(j);\\n            \"+on(p)+\" y1 = getTensorPosFromArrayIndex_y1(j);\\n\\n            ivec4 xPos = ivec4(\"+on(f)+\"(x1), \"+on(_)+\"(x2));\\n            ivec4 yPos = ivec4(\"+on(p)+\"(y1), \"+on(m)+\"(y2));\\n\\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\\n            float c = getValueFromTensorPos_counter(yPos.r, yPos.g, yPos.b, yPos.a);\\n            res += c * o;\\n        }\\n\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{counter:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"]}},matmul:tn,matmul_v2:tn,fc:{mainFunc:function(n,o){var e=n.origin,t=n.weight,r=o.x_num_col_dims,i=o.y_num_col_dims,s=un(e),a=un(t),u=rn(s,r),l=u[0],f=u[1],c=u[2],_=u[3],g=u[4],h=rn(a,i),d=h[0],p=h[1],P=h[2],m=h[3];return\"\\n    \"+sn(\"x1\",l,f)+\"\\n    \"+sn(\"x2\",c,_)+\"\\n    \"+sn(\"y1\",d,p)+\"\\n    \"+sn(\"y2\",P,m)+\"\\n\\n    // start函数\\n    void main(void) {\\n        float res = 0.0;\\n        // 获取output的坐标\\n        ivec4 opos = getOutputTensorPos();\\n        float bias = getValueFromTensorPos_bias(opos.r, opos.g, opos.b, opos.a);\\n        float temp = 0.0;\\n\\n        // output is 2D\\n        int b = opos.b;\\n        int a = opos.a;\\n\\n        \"+an(f)+\" x1 = getTensorPosFromArrayIndex_x1(b);\\n        \"+an(m)+\" y2 = getTensorPosFromArrayIndex_y2(a);\\n\\n        for (int j = 0; j < \"+g[1]+\"; j++) {\\n            \"+an(_)+\" x2 = getTensorPosFromArrayIndex_x2(j);\\n            \"+an(p)+\" y1 = getTensorPosFromArrayIndex_y1(j);\\n\\n            ivec4 xPos = ivec4(\"+an(f)+\"(x1), \"+an(_)+\"(x2));\\n            ivec4 yPos = ivec4(\"+an(p)+\"(y1), \"+an(m)+\"(y2));\\n\\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\\n            float c = getValueFromTensorPos_weight(yPos.r, yPos.g, yPos.b, yPos.a);\\n            res += c * o;\\n        }\\n\\n        res = res + bias;\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{weight:[\"getValueFromTensorPos\"],origin:[\"getValueFromTensorPos\"],bias:[\"getValueFromTensorPos\"]}},dropout:{mainFunc:function(n,o){return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        // 输出坐标转换为输入坐标\\n        float o = 0.0;\\n        o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n        if (\"+(\"downgrade_in_infer\"===o.dropout_implementation)+\") {\\n            o = o * (1.0 - \"+o.dropout_prob+\");\\n        }\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]}},concat:{mainFunc:function(n,o){var e=o.dim,t=Object.keys(n).filter((function(n){return\"out\"!==n})).map((function(o){return n[o]})).map((function(n){var o=n.width_shape,t=n.height_shape,r=n.channel;return[n.total_shape/(o*t*r),r,t,o][e]})),r=t.map((function(n,o){return t.slice(0,o+1).reduce((function(n,o){return n+o}),0)})),i=\"\";return r.forEach((function(n,o){i+=0===o?\"\\n            if (oPos[\"+e+\"] < \"+n+\") {\\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n            }\\n            \":\"\\n            else if (oPos[\"+e+\"] < \"+n+\") {\\n                oPos[\"+e+\"] = oPos[\"+e+\"] - \"+r[o-1]+\";\\n                o = getValueFromTensorPos_origin_\"+o+\"(oPos.r, oPos.g, oPos.b, oPos.a);\\n            }\\n            \"})),\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        // 输出坐标转换为输入坐标\\n        float o = 0.0;\\n        \"+i+\"\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{\"@all\":[\"getValueFromTensorPos\"]},behaviors:[\"normalizeDim\"]},concat_mul:{mainFunc:function(n,o){var e=o.dim,t=Object.keys(n).filter((function(n){return\"out\"!==n})).map((function(o){return n[o]})).map((function(n){var o=n.width_shape,t=n.height_shape,r=n.channel;return[n.total_shape/(o*t*r),r,t,o][e]})),r=t.map((function(n,o){return t.slice(0,o+1).reduce((function(n,o){return n+o}),0)})),i=\"\";return r.forEach((function(n,o){i+=0===o?\"\\n            if (oPos[\"+e+\"] < \"+n+\") {\\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n            }\":\"\\n            else if (oPos[\"+e+\"] < \"+n+\") {\\n                oPos[\"+e+\"] = oPos[\"+e+\"] - \"+r[o-1]+\";\\n                o = getValueFromTensorPos_origin_\"+o+\"(oPos.r, oPos.g, oPos.b, oPos.a);\\n            }\\n            \"})),\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        // 输出坐标转换为输入坐标\\n        float o = 0.0;\\n        \"+i+\"\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{\"@all\":[\"getValueFromTensorPos\"]},behaviors:[\"normalizeDim\"]},split:{mainFunc:function(n,o){var e=o.target_length,t=o.num,r=o.dim;return\"\\n    // start函数\\n    void main(void) {\\n        int length = int(\"+e+\" / \"+t+\");\\n        ivec4 oPos = getOutputTensorPos();\\n        // 输出坐标转换为输入坐标\\n        oPos[\"+r+\"] = oPos[\"+r+\"] + layer_run_time * length;\\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]},behaviors:[\"normalizeDim\"]},softmax:{mainFunc:function(n,o){var e=n.origin,t=o.axis,r=t;return(!t||t<0)&&(r=(t||-1)+4),\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        const int n = int(\"+e.total_shape+\"/\"+e.channel+\"/\"+e.height_shape+\"/\"+e.width_shape+\");\\n        float o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\\n        // 输出坐标转换为输入坐标\\n        float total = 0.0;\\n        float res = 0.0;\\n        if (\"+r+\" == 0) {\\n            for (int i = 0; i < n; i++){\\n            float temp = getValueFromTensorPos_origin(i, oPos[1], oPos[2], oPos[3]);\\n            total += exp(temp);\\n            }\\n            res = exp(o) / total;\\n        }\\n        else if (\"+r+\" == 1) {\\n            for (int i = 0; i < \"+e.channel+\"; i++){\\n            float temp = getValueFromTensorPos_origin(oPos[0], i, oPos[2], oPos[3]);\\n            total += exp(temp);\\n            }\\n            res = exp(o) / total;\\n        }\\n        else {\\n            for (int i = 0; i < \"+e.width_shape+\"; i++){\\n            float temp = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], i);\\n            total += exp(temp);\\n            }\\n            res = exp(o) / total;\\n        }\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]}},batchnorm:{mainFunc:function(n,o){var e=n.bias,t=n.scale,r=n.mean,i=n.variance,s=o.epsilon;return\"\\n    // start函数\\n    void main(void) {\\n        // 输出数据\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n\\n        // 归一化数据\\n        vec4 scale = getPixelsFromTexturePos_scale(vec2( float(oPos.g) / float(\"+t.width_texture+\") + 0.00001, 0.0));\\n        vec4 bias = getPixelsFromTexturePos_bias(vec2( float(oPos.g) / float(\"+e.width_texture+\") + 0.00001, 0.0));\\n        vec4 mean = getPixelsFromTexturePos_mean(vec2((float(oPos.g)) / float(\"+r.width_texture+\")  + 0.00001, 0.0));\\n        vec4 variance = getPixelsFromTexturePos_variance(\\n            vec2((float(oPos.g)) / float(\"+i.width_texture+\") + 0.00001,\\n            0.0)\\n        );\\n\\n        float x = (o - mean[0]) / sqrt(variance[0] + \"+s+\");\\n        float res = scale[0] * x + bias[0];\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"],scale:[\"getPixelsFromTexturePos\"],bias:[\"getPixelsFromTexturePos\"],mean:[\"getPixelsFromTexturePos\"],variance:[\"getPixelsFromTexturePos\"]}},reshape:ln,reshape2:ln,bilinear_interp:fn,transpose2:{mainFunc:function(n,o){var e=o.perm_arr,t=o.perm_size,r=e[0],i=e[1],s=e[2];return\"\\n    // start函数\\n    void main(void) {\\n        // 输出数据\\n        ivec4 oPos = getOutputTensorPos();\\n\\n        // 转置 坐标变换\\n        float o = 0.0;\\n        if (\"+t+\" == 1) {\\n            o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\\n        }\\n        else if (\"+t+\" == 2) {\\n            o = getValueFromTensorPos_origin(\\n                oPos[0], oPos[1],\\n                oPos[(2 + \"+r+\") > 3 ? 3 : (2 + \"+r+\")],\\n                oPos[(2 + \"+i+\") > 3 ? 3 : (2 + \"+i+\")]\\n            );\\n        }\\n        else if (\"+t+\" == 3) {\\n            o = getValueFromTensorPos_origin(\\n                oPos[0],\\n                oPos[(1 + \"+r+\") > 3 ? 3 : (1 + \"+r+\")],\\n                oPos[(1 + \"+i+\") > 3 ? 3 : (1 + \"+i+\")],\\n                oPos[(1 + \"+s+\") > 3 ? 3 : (1 + \"+s+\")]\\n            );\\n        }\\n        else if (\"+t+\" == 4) {\\n            o = getValueFromTensorPos_origin(\\n                oPos[\"+r+\"],\\n                oPos[\"+i+\"],\\n                oPos[\"+s+\"],\\n                oPos[\"+e[3]+\"]\\n            );\\n        }\\n\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]},behaviors:[\"normalizePerm\"]},unpacked_2_packed:{mainFunc:function(n,o){return\"\\n    // start函数\\n    void main() {\\n        ivec4 oPos = getOutputTensorPos();\\n        vec4 out4;\\n        for (int i = 0; i < 4; i++) {\\n            vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] * 4 + i, oPos[2], oPos[3]);\\n            out4[i] = o[0];\\n        }\\n        setPackedOutput(out4);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPosPacking\"]}},packed_2_unpacked:{mainFunc:function(n,o){return\"\\n    // start函数\\n    void main() {\\n        ivec4 oPos = getOutputTensorPos();\\n        float res = 0.0;\\n        int c1 = calMod(oPos[1], 4);\\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] / 4, oPos[2], oPos[3]);\\n\\n        if (c1 == 0) {\\n            res = o.r;\\n        } else if (c1 == 1) {\\n            res = o.g;\\n        } else if (c1 == 2) {\\n            res = o.b;\\n        } else if (c1 == 3) {\\n            res = o.a;\\n        }\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPosPacking\"]}},unsqueeze2:{mainFunc:function(n,o){var e=n.origin,t=o.axes,r=e.length_unformatted_shape,i=Array.isArray(t)?t:[t],s=4-r-i.length,a=i.map((function(n){return n+s})),u=[0,1,2,3].filter((function(n){return-1===a.indexOf(n)})).map((function(n){return\"oPos[\"+n+\"]\"})),l=Array.from(new Array(a.length),(function(){return\"0\"}));return u.splice.apply(u,function(){for(var n=0,o=0,e=arguments.length;o<e;o++)n+=arguments[o].length;var t=Array(n),r=0;for(o=0;o<e;o++)for(var i=arguments[o],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}([0,0],l)),\"\\n    void main() {\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = 0.0;\\n        o = getValueFromTensorPos_origin(\"+u.join(\",\")+\");\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]}},flatten_contiguous_range:{mainFunc:function(n,o){var e=n.origin,t=n.out;return\"\\n    void main() {\\n        ivec4 oPos = getOutputTensorPos();\\n        // 输出坐标转换为输入坐标\\n        int sumVal = oPos.a\\n            + oPos.b * \"+t.width_shape+\"\\n            + oPos.g * \"+t.height_shape+\" * \"+t.width_shape+\"\\n            + oPos.r * \"+t.channel+\" * \"+t.width_shape+\" * \"+t.height_shape+\";\\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\\n            sumVal,\\n            \"+e.channel+\",\\n            \"+e.width_shape+\",\\n            \"+e.height_shape+\",\\n            \"+e.total_shape+\"\\n        );\\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]},commonFuncConf:[\"transferFromNHWCtoNCHW\"]},flatten2:ln,greater_than:{mainFunc:function(n,o){return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        // 输出坐标转换为输入坐标\\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\\n\\n        setOutput(bool(x >= y));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"],counter:[\"getValueFromTensorPos\"]}},reduce_sum:{mainFunc:function(n,o){return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        // 输出坐标转换为输入坐标\\n        float o = 0.0;\\n        for (int i = 0; i < \"+o.inputs_dim+\"; i++) {\\n            oPos[\"+o.dim+\"] = i;\\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);;\\n        }\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]},behaviors:[\"normalizeDim\"]},where:{mainFunc:function(n,o){return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        // 输出坐标转换为输入坐标\\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\\n        float condition = getValueFromTensorPos_condition(oPos.r, oPos.g, oPos.b, oPos.a);\\n        float o = 0.0;\\n\\n        if (bool(condition)) {\\n            o = x;\\n        }\\n        else {\\n            o = y;\\n        }\\n        setOutput(o);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"],counter:[\"getValueFromTensorPos\"],condition:[\"getValueFromTensorPos\"]}},connect:{mainFunc:function(n,o){var e=n.out,t=e.total_shape,r=e.width_shape,i=e.height_shape,s=e.channel,a=_([t/(r*i*s),s,i,r]),u=Object.keys(n).filter((function(n){return\"out\"!==n})).map((function(o){return n[o].total_shape})),l=u.map((function(n,o){return u.slice(0,o+1).reduce((function(n,o){return n+o}),0)})),f=\"\";return l.forEach((function(n,o){f+=0===o?\"\\n            if (sumVal < \"+n+\") {\\n                co = getTensorPosFromArrayIndex_origin(sumVal);\\n                o = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\\n            }\":\"\\n            else if (sumVal < \"+n+\") {\\n                co = getTensorPosFromArrayIndex_origin_\"+o+\"(sumVal - \"+l[o-1]+\");\\n                o = getValueFromTensorPos_origin_\"+o+\"(co.r, co.g, co.b, co.a);\\n            }\\n            \"})),\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = 0.0;\\n        ivec4 co;\\n        int sumVal = oPos.b * \"+a[2]+\" + oPos.a;\\n        \"+f+\"\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{\"@all\":[\"getValueFromTensorPos\",\"getTensorPosFromArrayIndex\"]}},reduce_mean:{mainFunc:function(n,o){var e=o.inputs_dim;return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        // 输出坐标转换为输入坐标\\n        float o = 0.0;\\n        for (int i = 0; i < \"+e+\"; i++) {\\n            oPos[\"+o.dim+\"] = i;\\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n        }\\n        o = o / float(\"+e+\");\\n        setOutput(o);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]},behaviors:[\"normalizeDim\"]},hard_swish:{mainFunc:function(n,o){var e=o.offset,t=void 0===e?3:e,r=o.scale,i=void 0===r?6:r,s=o.threshold;return\"\\n    void main(void) {\\n        // 输出数据\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n        float res = o * min(max(0.0, o + float(\"+t+\")), float(\"+(void 0===s?6:s)+\")) / float(\"+i+\");\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]}},nearest_interp:pn,nearest_interp_v2:pn,cast:{mainFunc:function(n,o){var e=\"\";switch(o.out_dtype){case 0:e=\"\\n            float res_bool = 0.0;\\n            if (o != 0.0) {\\n                res_bool = 1.0;\\n            }\\n            setOutput(res_bool);\";break;case 1:case 2:case 3:e=\"\\n            int res_int = int(o);\\n            setOutput(float(res_int));\";break;default:e=\"       \\n            float res_float = o;\\n            setOutput(res_float);\"}return\"\\n    void main() {\\n       // 输出数据\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n        \"+e+\"\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]}},fill_constant_batch_size_like:{mainFunc:function(n,o){return\"\\n    // start函数\\n    void main(void) {\\n        float res = float(\"+o.value+\");\\n        setOutput(res);\\n    }\\n\"}},rnn_matmul:{mainFunc:function(n,o){var e=n.weightlist_0,t=o.input_axis,r=o.state_axis,i=o.batch,s=o.reverse,a=void 0!==s&&s?i-t-1:t;return\"\\n    void main() {\\n         float res = 0.0;\\n        // 获取output的坐标\\n        ivec4 out_pos = getOutputTensorPos();\\n        \\n        if (\"+(0===t)+\") {\\n            res = getValueFromTensorPos_origin(out_pos[0], \"+a+\", out_pos[2], out_pos[3]);\\n            setOutput(res);\\n            return;\\n        }\\n        \\n        ivec4 origin_pos = out_pos;\\n        ivec4 weight_pos = out_pos;\\n\\n        weight_pos[1] = 0;\\n        weight_pos[2] = weight_pos[3];\\n\\n        float o = 0.0;\\n        float w_hh = 0.0;\\n        float prestate_h = 0.0;\\n        res = getValueFromTensorPos_origin(out_pos[0], \"+a+\", out_pos[2], out_pos[3]);\\n        for (int j = 0; j < \"+e.width_shape+\"; j++) {\\n            prestate_h = getValueFromTensorPos_prestate(origin_pos[0], origin_pos[1], origin_pos[2], j);\\n            w_hh = getValueFromTensorPos_weightlist_0(out_pos[0], \"+r+\", out_pos[3], j);\\n            o += w_hh * prestate_h;\\n        }\\n        res += o;\\n\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"],prestate:[\"getValueFromTensorPos\"],weightlist_0:[\"getValueFromTensorPos\"]}},rnn_hidden:{mainFunc:function(n,o){var e=o.state_axis,t=o.hidden_size;return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + \"+t+\");\\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + \"+2*t+\");\\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + \"+3*t+\");\\n        float counter  = getValueFromTensorPos_counter(oPos.r, \"+e+\", oPos.b, oPos.a);\\n        float i = 1.0 / (1.0 + exp(-origin));\\n        float f = 1.0 / (1.0 + exp(-cell));\\n        float o = 1.0 / (1.0 + exp(-fourth));\\n        float c = f * counter + i * tanh_calc(appender);\\n        float h = o * tanh_calc(c);\\n        \\n        setOutput(h);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"],counter:[\"getValueFromTensorPos\"]}},rnn_cell:{mainFunc:function(n,o){var e=o.state_axis,t=o.hidden_size;return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + \"+t+\");\\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + \"+2*t+\");\\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + \"+3*t+\");\\n        float counter  = getValueFromTensorPos_counter(oPos.r, \"+e+\", oPos.b, oPos.a);\\n        float i = 1.0 / (1.0 + exp(-origin));\\n        float f = 1.0 / (1.0 + exp(-cell));\\n        float c = f * counter + i * tanh_calc(appender);\\n        \\n        setOutput(c);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"],counter:[\"getValueFromTensorPos\"]}},rnn_origin:{mainFunc:function(n,o){var e=n.weightlist_0,t=n.weightlist_1,r=o.state_axis;return\"\\n    void main() {\\n        float res = 0.0;\\n        // 获取output的坐标\\n        ivec4 out_pos = getOutputTensorPos();\\n        ivec4 origin_pos = out_pos;\\n        ivec4 weight_pos = out_pos;\\n      \\n        weight_pos[1] = 0;\\n        weight_pos[2] = weight_pos[3];\\n\\n        float b_ih = getValueFromTensorPos_weightlist_2(0, 0, 0, out_pos[3]);\\n        float b_hh = getValueFromTensorPos_weightlist_3(0, 0, 0, out_pos[3]);\\n        \\n        for (int j = 0; j < \"+e.width_shape+\"; j++) {\\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], 0, j);\\n            float w_ih = getValueFromTensorPos_weightlist_0(0, 0, out_pos[3], j);\\n            res += w_ih * o;\\n        }\\n        res += b_ih;\\n\\n        for (int j = 0; j < \"+t.width_shape+\"; j++) {\\n                float prestate = getValueFromTensorPos_prestate(0, 0, 0, j);\\n                float w_hh = getValueFromTensorPos_weightlist_1(0, \"+r+\", out_pos[3], j);\\n                res += w_hh * prestate;\\n        }\\n        res += b_hh;\\n \\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"],prestate:[\"getValueFromTensorPos\"],weightlist_0:[\"getValueFromTensorPos\"],weightlist_1:[\"getValueFromTensorPos\"],weightlist_2:[\"getValueFromTensorPos\"],weightlist_3:[\"getValueFromTensorPos\"]}},pool2d_avg:{mainFunc:function(n,o){var e=n.origin,t=o.strides,r=void 0===t?[]:t,i=o.paddings,s=void 0===i?[]:i,a=o.ksize,u=r[0],l=void 0===u?1:u,f=r[1],c=void 0===f?1:f,_=s[0],g=void 0===_?0:_,h=s[1],d=void 0===h?0:h,p=a[0],P=a[1];return\"\\n    // start函数\\n    void main(void) {\\n        float res = 0.0;\\n        // 获取output的坐标\\n        ivec4 out_pos = getOutputTensorPos();\\n        // X、Y方向的移动步长\\n        int oy_base = out_pos[2] * \"+l+\" - \"+g+\";\\n        int ox_base = out_pos[3] * \"+c+\" - \"+d+\";\\n        for (int fy = 0; fy < \"+p+\"; fy++) {\\n            int oy = oy_base + fy;\\n            if (oy >= \"+e.height_shape+\") {\\n                break;\\n            }\\n            if (oy < 0) {\\n                continue;\\n            }\\n            for (int fx = 0; fx < \"+P+\"; fx++) {\\n                int ox = ox_base + fx;\\n                if (ox >= \"+e.width_shape+\") {\\n                    break;\\n                }\\n                if (ox < 0) {\\n                    continue;\\n                }\\n                // origin数据\\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\\n                res += curr;\\n                // 在平均池化模式忽略填充值(exclusive默认为true）\\n            }\\n        }\\n        res = res / float(\"+p+\" * \"+P+\");\\n        setOutput(res);\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]},behaviors:[\"setPacked\",\"setAdaptive\",\"isGlobalPooling\"]},prelu:hn(\"prelu\"),relu6:hn(\"relu6\"),leakyRelu:hn(\"leakyRelu\"),scale:hn(\"scale\"),sigmoid:hn(\"sigmoid\"),relu:hn(\"relu\"),hard_sigmoid:hn(\"hard_sigmoid\"),pow:hn(\"pow\"),sqrt:hn(\"sqrt\"),tanh:hn(\"tanh\"),squeeze2:dn,pad3d:{mainFunc:function(n,o){var e=n.origin,t=o.paddings,r=o.mode,i=o.value,s=function(n){var o=n.total_shape,e=n.channel,t=n.height_shape,r=n.width_shape;return[o/e/t/r,e,t,r]}(e),a={reflect:\"\\n            int a;\\n            int b;\\n            if (oPos.a - \"+t[0]+\" < 0) {\\n                a = \"+t[0]+\" - oPos.a;\\n            }\\n            else if (oPos.a - \"+t[0]+\" >= \"+s[3]+\") {\\n                a = \"+s[3]+\" - (oPos.a - \"+t[0]+\" - \"+s[3]+\" + 1) - 1;\\n            }\\n            else {\\n                a = oPos.a - \"+t[0]+\";\\n            }\\n            if (oPos.b - \"+t[2]+\" < 0) {\\n                b = \"+t[2]+\" - oPos.b;\\n            }\\n            else if (oPos.b - \"+t[2]+\" >= \"+s[2]+\") {\\n                b = \"+s[2]+\" - (oPos.b - \"+t[2]+\" - \"+s[2]+\" + 1) - 1;\\n            }\\n            else {\\n                b = oPos.b - \"+t[2]+\";\\n            }\\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\\n        \",replicate:\"\\n            int a;\\n            int b;\\n            if (oPos.a - \"+t[0]+\" < 0) {\\n                a = 0;\\n            }\\n            else if (oPos.a - \"+t[0]+\" >= \"+s[3]+\") {\\n                a = \"+s[3]+\" - 1;\\n            }\\n            else {\\n                a = oPos.a - \"+t[0]+\";\\n            }\\n            if (oPos.b - \"+t[2]+\" < 0) {\\n                b = 0;\\n            }\\n            else if (oPos.b - \"+t[2]+\" >= \"+s[2]+\") {\\n                b = \"+s[2]+\" - 1;\\n            }\\n            else {\\n                b = oPos.b - \"+t[2]+\";\\n            }\\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\\n        \",circular:\"\\n            int a;\\n            int b;\\n            if (oPos.a - \"+t[0]+\" < 0) {\\n                a = int(mod(float(\"+t[0]+\" + oPos.a - 1), float(\"+s[3]+\")));\\n            }\\n            else if (oPos.a - \"+t[0]+\" >= \"+s[3]+\") {\\n                a = int(mod(float(oPos.a - \"+t[0]+\" - \"+s[3]+\"), float(\"+s[3]+\")));\\n            }\\n            else {\\n                a = oPos.a - \"+t[0]+\";\\n            }\\n            if (oPos.b - \"+t[2]+\" < 0) {\\n                b = int(mod(float(\"+t[2]+\" + oPos.b - 1), float(\"+s[2]+\")));\\n            }\\n            else if (oPos.b - \"+t[2]+\" >= \"+s[2]+\") {\\n                b = int(mod(float(oPos.b - \"+t[2]+\" - \"+s[2]+\"), float(\"+s[2]+\")));\\n            }\\n            else {\\n                b = oPos.b - \"+t[2]+\";\\n            }\\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\\n        \",constant:\"\",undefined:\"\"};return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = \"+(i||\"0.0\")+\";\\n        if (oPos.a - \"+t[0]+\" >= 0\\n            && oPos.b - \"+t[2]+\" >= 0\\n            && oPos.a - \"+t[0]+\" < \"+s[3]+\"\\n            && oPos.b - \"+t[2]+\" < \"+s[2]+\"\\n        ) {\\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b - \"+t[2]+\", oPos.a - \"+t[0]+\");\\n        }\\n        else {\\n            \"+a[r]+\"\\n        }\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]}},bilinear_interp_v2:cn,shuffle_channel:{mainFunc:function(n,o){var e=n.out,t=o.group,r=void 0===t?2:t,i=e.total_shape,s=e.height_shape,a=e.width_shape,u=e.channel,l=[1,0,2,3];return\"\\n    // start函数\\n    void main(void) {\\n        // 输出数据\\n        ivec4 oPos = getOutputTensorPos();\\n        float o = 0.0;\\n\\n        int sumVal = oPos.a\\n            + oPos.b * \"+a+\"\\n            + oPos.g * \"+s+\" * \"+a+\"\\n            + oPos.r * \"+u+\" * \"+a+\" * \"+s+\";\\n\\n        ivec4 transpose_out_pos = transferFromNHWCtoNCHW(\\n            sumVal,\\n            \"+r+\",\\n            \"+a+\",\\n            \"+s+\",\\n            \"+i+\"\\n        );\\n\\n        ivec4 transpose_in_pos = ivec4(transpose_out_pos[\"+l[0]+\"],\\n            transpose_out_pos[\"+l[1]+\"], transpose_out_pos[\"+l[2]+\"], transpose_out_pos[\"+l[3]+\"]);\\n        int sumVal2 = transpose_in_pos.a\\n            + transpose_in_pos.b * \"+a+\"\\n            + transpose_in_pos.g * \"+s+\" * \"+a+\"\\n            + transpose_in_pos.r * \"+u/r+\" * \"+a+\" * \"+s+\";\\n        ivec4 origin_oPos = transferFromNHWCtoNCHW(\\n            sumVal2,\\n            \"+u+\",\\n            \"+a+\",\\n            \"+s+\",\\n            \"+i+\"\\n        );\\n\\n\\n        o = getValueFromTensorPos_origin(\\n            origin_oPos[0],\\n            origin_oPos[1],\\n            origin_oPos[2],\\n            origin_oPos[3]\\n        );\\n\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]},commonFuncConf:[\"transferFromNHWCtoNCHW\"]},pack_out:{mainFunc:function(n,o){return\"\\n\\n    // start函数\\n    void main() {\\n        ivec4 oPos = getOutputTensorPos();\\n        vec2 outCoord = vCoord.xy * _2d_shape_texture_out;\\n        int index = int(outCoord.x) + int(outCoord.y) * int(\"+n.out.width_texture+\");\\n\\n        int first = index * 4;\\n        int sec = index * 4 + 1;\\n        int third = index * 4 + 2;\\n        int fourth = index * 4 + 3;\\n\\n        ivec4 rPos = getTensorPosFromArrayIndex_origin(first);\\n        ivec4 gPos = getTensorPosFromArrayIndex_origin(sec);\\n        ivec4 bPos = getTensorPosFromArrayIndex_origin(third);\\n        ivec4 aPos = getTensorPosFromArrayIndex_origin(fourth);\\n\\n        float r = getValueFromTensorPos_origin(rPos.r, rPos.g, rPos.b, rPos.a);\\n        float g = getValueFromTensorPos_origin(gPos.r, gPos.g, gPos.b, gPos.a);\\n        float b = getValueFromTensorPos_origin(bPos.r, bPos.g, bPos.b, bPos.a);\\n        float a = getValueFromTensorPos_origin(aPos.r, aPos.g, aPos.b, aPos.a);\\n\\n        setPackedOutput(vec4(r, g, b, a));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\",\"getTensorPosFromArrayIndex\"]}},nhwc_2_nchw:{mainFunc:function(n,o){var e=n.origin,t=n.out;return\"\\n    void main() {\\n        ivec4 oPos = getOutputTensorPos();\\n        // 输出坐标转换为输入坐标\\n        int sumVal = oPos.a * \"+t.channel+\"\\n            + oPos.b * \"+t.width_shape+\" * \"+t.channel+\"\\n            + oPos.g\\n            + oPos.r * \"+t.channel+\" * \"+t.width_shape+\" * \"+t.height_shape+\";\\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\\n            sumVal,\\n            \"+e.channel+\",\\n            \"+e.width_shape+\",\\n            \"+e.height_shape+\",\\n            \"+e.total_shape+\"\\n        );\\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPos\"]},commonFuncConf:[\"transferFromNHWCtoNCHW\"]},feedPost:{mainFunc:function(n,o){var e=n.out,t=o.mean,r=void 0===t?[0,0,0]:t,i=o.std,s=void 0===i?[1,1,1]:i,a=e.total_shape,u=e.height_shape,l=e.width_shape,f=e.channel;return\"\\n    // start函数\\n    void main(void) {\\n        ivec4 nhwcPos = getOutputTensorPos();\\n        int sumVal = nhwcPos.a\\n            + nhwcPos.b * \"+l+\"\\n            + nhwcPos.g * \"+u+\" * \"+l+\"\\n            + nhwcPos.r * \"+f+\" * \"+l+\" * \"+u+\";\\n\\n        ivec4 oPos = transferFromNHWCtoNCHW(\\n            sumVal,\\n            \"+f+\",\\n            \"+l+\",\\n            \"+u+\",\\n            \"+a+\"\\n        );\\n        float res = 0.0;\\n        int c1 = int(mod(float(oPos[1]), 4.0));\\n        int c = oPos[1];\\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], c / 4, oPos[2], oPos[3]);\\n\\n        if (c1 == 0) {\\n            res = o.r;\\n        } else if (c1 == 1) {\\n            res = o.g;\\n        } else if (c1 == 2) {\\n            res = o.b;\\n        } else if (c1 == 3) {\\n            res = o.a;\\n        }\\n\\n        if (c == 0) {\\n            res = (res - float(\"+r[0]+\")) / float(\"+s[0]+\");\\n        } else if (c == 1) {\\n            res = (res - float(\"+r[1]+\")) / float(\"+s[1]+\");\\n        } else if (c == 2) {\\n            res = (res - float(\"+r[2]+\")) / float(\"+s[2]+\");\\n        }\\n        setOutput(float(res));\\n    }\\n    \"},textureFuncConf:{origin:[\"getValueFromTensorPosPacking\"]},commonFuncConf:[\"transferFromNHWCtoNCHW\"]},imgFeed:{mainFunc:function(){return\"\\n    uniform vec2 u_scale;\\n    void main(void) {\\n        vec2 outCoord = vCoord.xy;\\n        vec2 newPos = vCoord / u_scale;\\n        vec2 startPos = (1.0 / u_scale - 1.0) / 2.0;\\n        bool exceedX = u_scale.y == 1.0 && (newPos.x < startPos.x || newPos.x > (1.0 + startPos.x));\\n        bool exceedY = u_scale.x == 1.0 && (newPos.y < startPos.y || newPos.y > (1.0 + startPos.y));\\n        if (exceedX || exceedY) {\\n            setPackedOutput(vec4(1.0, 1.0, 1.0, 1.0));\\n            return;\\n        }\\n        newPos = newPos - startPos;\\n        vec4 counter = TEXTURE2D(texture_origin, newPos);\\n        setPackedOutput(counter);\\n    }\\n    \"},textureFuncConf:{origin:[]}},box_coder:{mainFunc:function(n,o){var e=\"decode_center_size\"===o.code_type;return\"\\n    // start函数\\n    vec2 getPriorBoxData(int r, int g, int b, int m, int n) {\\n        float start = getValueFromTensorPos_priorbox(r, g, b, m);\\n        float end = getValueFromTensorPos_priorbox(r, g, b, n);\\n        float len = end - start;\\n        return vec2(start + len / 2.0, len);\\n    }\\n    vec2 getBoxVarData(int r, int g, int b, int m, int n) {\\n        return vec2(\\n            getValueFromTensorPos_priorboxvar(r, g, b, m),\\n            getValueFromTensorPos_priorboxvar(r, g, b, n)\\n        );\\n    }\\n    vec2 getTargetBoxData(int r, int g, int b, int m, int n) {\\n        \"+(e?\"\\n            return vec2(\\n                getValueFromTensorPos_targetbox(r, g, b, m),\\n                getValueFromTensorPos_targetbox(r, g, b, n)\\n            );\\n        \":\"\\n            float start = getValueFromTensorPos_targetbox(r, g, b, m);\\n            float end = getValueFromTensorPos_targetbox(r, g, b, n);\\n            float len = end - start;\\n            return vec2(start + len / 2.0, len);\\n        \")+\"\\n    }\\n\\n    void main(void) {\\n        ivec4 oPos = getOutputTensorPos();\\n        int r = int(oPos.r);\\n        int g = int(oPos.g);\\n        int b = int(oPos.b);\\n        int a = int(oPos.a);\\n        // 输出坐标转换为输入坐标\\n        float o = 0.0;\\n\\n        int m = 0;\\n        int n = 0;\\n        if (a == 0 || a == \"+(e?2:1)+\") {\\n            m = 0;\\n            n = 2;\\n        }\\n        else {\\n            m = 1;\\n            n = 3;\\n        }\\n        vec2 priorbox = getPriorBoxData(r, g, b, m, n);\\n        vec2 boxvar = getBoxVarData(r, g, b, m, n);\\n        vec2 targetbox = getTargetBoxData(r, g, b, m, n);\\n        float p1 = priorbox.r;\\n        float p2 = priorbox.g;\\n        float t1 = targetbox.r;\\n        float t2 = targetbox.g;\\n        float v1 = boxvar.r;\\n        float v2 = boxvar.g;\\n\\n        \"+(e?\"\\n            float b1 = p2 * v1 * t1 + p1;\\n            float b2 = exp(v2 * t2) * p2;\\n            if (a == 0 || a == 1) {\\n                o = b1 - b2 / 2.0 ;\\n            }\\n            else {\\n                o = b1 + b2 / 2.0;\\n            }\\n        \":\"\\n            if (a == 0 || a == 1) {\\n                o = (t1 - p1) / p2 / v1;\\n            }\\n            else {\\n                o = log(abs(t2 / p2)) / v2;\\n            }\\n        \")+\"\\n        setOutput(float(o));\\n    }\\n    \"},textureFuncConf:{targetbox:[\"getValueFromTensorPos\"],priorbox:[\"getValueFromTensorPos\"],priorboxvar:[\"getValueFromTensorPos\"]},behaviors:[]},density_prior_box:mn,prior_box:vn},Tn=new Q;!function(n,o,e){n&&(u.backend=n),o&&(u.backendInstance=o),e&&Object.keys(e).forEach((function(n){!function(n,o){var e=n.conf,t=n.params,r=n.main,i=n.mainFunc,s=n.textureFuncConf,a=n.commonFuncConf,l=n.behaviors,f=void 0===l?[]:l,c=u.backend+\"_\"+o;u.opRegistry.ops[c]||(u.opRegistry.ops[c]={name:o,conf:e,params:t,main:r,mainFunc:i,textureFuncConf:s,commonFuncConf:a,behaviors:f})}(e[n],n)}))}(\"webgl\",Tn,xn)}},o={};function e(t){if(o[t])return o[t].exports;var r=o[t]={exports:{}};return n[t](r,r.exports,e),r.exports}return e.d=(n,o)=>{for(var t in o)e.o(o,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:o[t]})},e.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(n){if(\"object\"==typeof window)return window}}(),e.o=(n,o)=>Object.prototype.hasOwnProperty.call(n,o),e.r=n=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(n,\"__esModule\",{value:!0})},e(646)})()}));"]}